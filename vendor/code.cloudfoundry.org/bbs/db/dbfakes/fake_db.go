// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/bbs/db"
	"code.cloudfoundry.org/bbs/models"
	"code.cloudfoundry.org/lager"
)

type FakeDB struct {
	FreshDomainsStub        func(logger lager.Logger) ([]string, error)
	freshDomainsMutex       sync.RWMutex
	freshDomainsArgsForCall []struct {
		logger lager.Logger
	}
	freshDomainsReturns struct {
		result1 []string
		result2 error
	}
	freshDomainsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	UpsertDomainStub        func(lgger lager.Logger, domain string, ttl uint32) error
	upsertDomainMutex       sync.RWMutex
	upsertDomainArgsForCall []struct {
		lgger  lager.Logger
		domain string
		ttl    uint32
	}
	upsertDomainReturns struct {
		result1 error
	}
	upsertDomainReturnsOnCall map[int]struct {
		result1 error
	}
	EncryptionKeyLabelStub        func(logger lager.Logger) (string, error)
	encryptionKeyLabelMutex       sync.RWMutex
	encryptionKeyLabelArgsForCall []struct {
		logger lager.Logger
	}
	encryptionKeyLabelReturns struct {
		result1 string
		result2 error
	}
	encryptionKeyLabelReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SetEncryptionKeyLabelStub        func(logger lager.Logger, encryptionKeyLabel string) error
	setEncryptionKeyLabelMutex       sync.RWMutex
	setEncryptionKeyLabelArgsForCall []struct {
		logger             lager.Logger
		encryptionKeyLabel string
	}
	setEncryptionKeyLabelReturns struct {
		result1 error
	}
	setEncryptionKeyLabelReturnsOnCall map[int]struct {
		result1 error
	}
	PerformEncryptionStub        func(logger lager.Logger) error
	performEncryptionMutex       sync.RWMutex
	performEncryptionArgsForCall []struct {
		logger lager.Logger
	}
	performEncryptionReturns struct {
		result1 error
	}
	performEncryptionReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveEvacuatingActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) error
	removeEvacuatingActualLRPMutex       sync.RWMutex
	removeEvacuatingActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}
	removeEvacuatingActualLRPReturns struct {
		result1 error
	}
	removeEvacuatingActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	EvacuateActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) (actualLRP *models.ActualLRP, err error)
	evacuateActualLRPMutex       sync.RWMutex
	evacuateActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
		arg4 *models.ActualLRPNetInfo
	}
	evacuateActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 error
	}
	evacuateActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 error
	}
	ActualLRPsStub        func(logger lager.Logger, filter models.ActualLRPFilter) ([]*models.ActualLRP, error)
	actualLRPsMutex       sync.RWMutex
	actualLRPsArgsForCall []struct {
		logger lager.Logger
		filter models.ActualLRPFilter
	}
	actualLRPsReturns struct {
		result1 []*models.ActualLRP
		result2 error
	}
	actualLRPsReturnsOnCall map[int]struct {
		result1 []*models.ActualLRP
		result2 error
	}
	CreateUnclaimedActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey) (after *models.ActualLRP, err error)
	createUnclaimedActualLRPMutex       sync.RWMutex
	createUnclaimedActualLRPArgsForCall []struct {
		logger lager.Logger
		key    *models.ActualLRPKey
	}
	createUnclaimedActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 error
	}
	createUnclaimedActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 error
	}
	UnclaimActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey) (before *models.ActualLRP, after *models.ActualLRP, err error)
	unclaimActualLRPMutex       sync.RWMutex
	unclaimActualLRPArgsForCall []struct {
		logger lager.Logger
		key    *models.ActualLRPKey
	}
	unclaimActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	unclaimActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	ClaimActualLRPStub        func(logger lager.Logger, processGuid string, index int32, instanceKey *models.ActualLRPInstanceKey) (before *models.ActualLRP, after *models.ActualLRP, err error)
	claimActualLRPMutex       sync.RWMutex
	claimActualLRPArgsForCall []struct {
		logger      lager.Logger
		processGuid string
		index       int32
		instanceKey *models.ActualLRPInstanceKey
	}
	claimActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	claimActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	StartActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, netInfo *models.ActualLRPNetInfo) (before *models.ActualLRP, after *models.ActualLRP, err error)
	startActualLRPMutex       sync.RWMutex
	startActualLRPArgsForCall []struct {
		logger      lager.Logger
		key         *models.ActualLRPKey
		instanceKey *models.ActualLRPInstanceKey
		netInfo     *models.ActualLRPNetInfo
	}
	startActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	startActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	CrashActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, crashReason string) (before *models.ActualLRP, after *models.ActualLRP, shouldRestart bool, err error)
	crashActualLRPMutex       sync.RWMutex
	crashActualLRPArgsForCall []struct {
		logger      lager.Logger
		key         *models.ActualLRPKey
		instanceKey *models.ActualLRPInstanceKey
		crashReason string
	}
	crashActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 bool
		result4 error
	}
	crashActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 bool
		result4 error
	}
	FailActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey, placementError string) (before *models.ActualLRP, after *models.ActualLRP, err error)
	failActualLRPMutex       sync.RWMutex
	failActualLRPArgsForCall []struct {
		logger         lager.Logger
		key            *models.ActualLRPKey
		placementError string
	}
	failActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	failActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	RemoveActualLRPStub        func(logger lager.Logger, processGuid string, index int32, instanceKey *models.ActualLRPInstanceKey) error
	removeActualLRPMutex       sync.RWMutex
	removeActualLRPArgsForCall []struct {
		logger      lager.Logger
		processGuid string
		index       int32
		instanceKey *models.ActualLRPInstanceKey
	}
	removeActualLRPReturns struct {
		result1 error
	}
	removeActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	ChangeActualLRPPresenceStub        func(logger lager.Logger, key *models.ActualLRPKey, from, to models.ActualLRP_Presence) (before *models.ActualLRP, after *models.ActualLRP, err error)
	changeActualLRPPresenceMutex       sync.RWMutex
	changeActualLRPPresenceArgsForCall []struct {
		logger lager.Logger
		key    *models.ActualLRPKey
		from   models.ActualLRP_Presence
		to     models.ActualLRP_Presence
	}
	changeActualLRPPresenceReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	changeActualLRPPresenceReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	CountActualLRPsByStateStub        func(logger lager.Logger) (int, int, int, int, int)
	countActualLRPsByStateMutex       sync.RWMutex
	countActualLRPsByStateArgsForCall []struct {
		logger lager.Logger
	}
	countActualLRPsByStateReturns struct {
		result1 int
		result2 int
		result3 int
		result4 int
		result5 int
	}
	countActualLRPsByStateReturnsOnCall map[int]struct {
		result1 int
		result2 int
		result3 int
		result4 int
		result5 int
	}
	CountDesiredInstancesStub        func(logger lager.Logger) int
	countDesiredInstancesMutex       sync.RWMutex
	countDesiredInstancesArgsForCall []struct {
		logger lager.Logger
	}
	countDesiredInstancesReturns struct {
		result1 int
	}
	countDesiredInstancesReturnsOnCall map[int]struct {
		result1 int
	}
	DesiredLRPsStub        func(logger lager.Logger, filter models.DesiredLRPFilter) ([]*models.DesiredLRP, error)
	desiredLRPsMutex       sync.RWMutex
	desiredLRPsArgsForCall []struct {
		logger lager.Logger
		filter models.DesiredLRPFilter
	}
	desiredLRPsReturns struct {
		result1 []*models.DesiredLRP
		result2 error
	}
	desiredLRPsReturnsOnCall map[int]struct {
		result1 []*models.DesiredLRP
		result2 error
	}
	DesiredLRPByProcessGuidStub        func(logger lager.Logger, processGuid string) (*models.DesiredLRP, error)
	desiredLRPByProcessGuidMutex       sync.RWMutex
	desiredLRPByProcessGuidArgsForCall []struct {
		logger      lager.Logger
		processGuid string
	}
	desiredLRPByProcessGuidReturns struct {
		result1 *models.DesiredLRP
		result2 error
	}
	desiredLRPByProcessGuidReturnsOnCall map[int]struct {
		result1 *models.DesiredLRP
		result2 error
	}
	DesiredLRPSchedulingInfosStub        func(logger lager.Logger, filter models.DesiredLRPFilter) ([]*models.DesiredLRPSchedulingInfo, error)
	desiredLRPSchedulingInfosMutex       sync.RWMutex
	desiredLRPSchedulingInfosArgsForCall []struct {
		logger lager.Logger
		filter models.DesiredLRPFilter
	}
	desiredLRPSchedulingInfosReturns struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}
	desiredLRPSchedulingInfosReturnsOnCall map[int]struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}
	DesireLRPStub        func(logger lager.Logger, desiredLRP *models.DesiredLRP) error
	desireLRPMutex       sync.RWMutex
	desireLRPArgsForCall []struct {
		logger     lager.Logger
		desiredLRP *models.DesiredLRP
	}
	desireLRPReturns struct {
		result1 error
	}
	desireLRPReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateDesiredLRPStub        func(logger lager.Logger, processGuid string, update *models.DesiredLRPUpdate) (beforeDesiredLRP *models.DesiredLRP, err error)
	updateDesiredLRPMutex       sync.RWMutex
	updateDesiredLRPArgsForCall []struct {
		logger      lager.Logger
		processGuid string
		update      *models.DesiredLRPUpdate
	}
	updateDesiredLRPReturns struct {
		result1 *models.DesiredLRP
		result2 error
	}
	updateDesiredLRPReturnsOnCall map[int]struct {
		result1 *models.DesiredLRP
		result2 error
	}
	RemoveDesiredLRPStub        func(logger lager.Logger, processGuid string) error
	removeDesiredLRPMutex       sync.RWMutex
	removeDesiredLRPArgsForCall []struct {
		logger      lager.Logger
		processGuid string
	}
	removeDesiredLRPReturns struct {
		result1 error
	}
	removeDesiredLRPReturnsOnCall map[int]struct {
		result1 error
	}
	ConvergeLRPsStub        func(logger lager.Logger, cellSet models.CellSet) db.ConvergenceResult
	convergeLRPsMutex       sync.RWMutex
	convergeLRPsArgsForCall []struct {
		logger  lager.Logger
		cellSet models.CellSet
	}
	convergeLRPsReturns struct {
		result1 db.ConvergenceResult
	}
	convergeLRPsReturnsOnCall map[int]struct {
		result1 db.ConvergenceResult
	}
	TasksStub        func(logger lager.Logger, filter models.TaskFilter) ([]*models.Task, error)
	tasksMutex       sync.RWMutex
	tasksArgsForCall []struct {
		logger lager.Logger
		filter models.TaskFilter
	}
	tasksReturns struct {
		result1 []*models.Task
		result2 error
	}
	tasksReturnsOnCall map[int]struct {
		result1 []*models.Task
		result2 error
	}
	TaskByGuidStub        func(logger lager.Logger, taskGuid string) (*models.Task, error)
	taskByGuidMutex       sync.RWMutex
	taskByGuidArgsForCall []struct {
		logger   lager.Logger
		taskGuid string
	}
	taskByGuidReturns struct {
		result1 *models.Task
		result2 error
	}
	taskByGuidReturnsOnCall map[int]struct {
		result1 *models.Task
		result2 error
	}
	DesireTaskStub        func(logger lager.Logger, taskDefinition *models.TaskDefinition, taskGuid, domain string) (*models.Task, error)
	desireTaskMutex       sync.RWMutex
	desireTaskArgsForCall []struct {
		logger         lager.Logger
		taskDefinition *models.TaskDefinition
		taskGuid       string
		domain         string
	}
	desireTaskReturns struct {
		result1 *models.Task
		result2 error
	}
	desireTaskReturnsOnCall map[int]struct {
		result1 *models.Task
		result2 error
	}
	StartTaskStub        func(logger lager.Logger, taskGuid, cellId string) (before *models.Task, after *models.Task, shouldStart bool, rr error)
	startTaskMutex       sync.RWMutex
	startTaskArgsForCall []struct {
		logger   lager.Logger
		taskGuid string
		cellId   string
	}
	startTaskReturns struct {
		result1 *models.Task
		result2 *models.Task
		result3 bool
		result4 error
	}
	startTaskReturnsOnCall map[int]struct {
		result1 *models.Task
		result2 *models.Task
		result3 bool
		result4 error
	}
	CancelTaskStub        func(logger lager.Logger, taskGuid string) (before *models.Task, after *models.Task, cellID string, err error)
	cancelTaskMutex       sync.RWMutex
	cancelTaskArgsForCall []struct {
		logger   lager.Logger
		taskGuid string
	}
	cancelTaskReturns struct {
		result1 *models.Task
		result2 *models.Task
		result3 string
		result4 error
	}
	cancelTaskReturnsOnCall map[int]struct {
		result1 *models.Task
		result2 *models.Task
		result3 string
		result4 error
	}
	FailTaskStub        func(logger lager.Logger, taskGuid, failureReason string) (before *models.Task, after *models.Task, err error)
	failTaskMutex       sync.RWMutex
	failTaskArgsForCall []struct {
		logger        lager.Logger
		taskGuid      string
		failureReason string
	}
	failTaskReturns struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}
	failTaskReturnsOnCall map[int]struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}
	RejectTaskStub        func(logger lager.Logger, taskGuid, rejectionReason string) (before *models.Task, after *models.Task, err error)
	rejectTaskMutex       sync.RWMutex
	rejectTaskArgsForCall []struct {
		logger          lager.Logger
		taskGuid        string
		rejectionReason string
	}
	rejectTaskReturns struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}
	rejectTaskReturnsOnCall map[int]struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}
	CompleteTaskStub        func(logger lager.Logger, taskGuid, cellId string, failed bool, failureReason, result string) (before *models.Task, after *models.Task, err error)
	completeTaskMutex       sync.RWMutex
	completeTaskArgsForCall []struct {
		logger        lager.Logger
		taskGuid      string
		cellId        string
		failed        bool
		failureReason string
		result        string
	}
	completeTaskReturns struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}
	completeTaskReturnsOnCall map[int]struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}
	ResolvingTaskStub        func(logger lager.Logger, taskGuid string) (before *models.Task, after *models.Task, err error)
	resolvingTaskMutex       sync.RWMutex
	resolvingTaskArgsForCall []struct {
		logger   lager.Logger
		taskGuid string
	}
	resolvingTaskReturns struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}
	resolvingTaskReturnsOnCall map[int]struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}
	DeleteTaskStub        func(logger lager.Logger, taskGuid string) (task *models.Task, err error)
	deleteTaskMutex       sync.RWMutex
	deleteTaskArgsForCall []struct {
		logger   lager.Logger
		taskGuid string
	}
	deleteTaskReturns struct {
		result1 *models.Task
		result2 error
	}
	deleteTaskReturnsOnCall map[int]struct {
		result1 *models.Task
		result2 error
	}
	ConvergeTasksStub        func(logger lager.Logger, cellSet models.CellSet, kickTaskDuration, expirePendingTaskDuration, expireCompletedTaskDuration time.Duration) db.TaskConvergenceResult
	convergeTasksMutex       sync.RWMutex
	convergeTasksArgsForCall []struct {
		logger                      lager.Logger
		cellSet                     models.CellSet
		kickTaskDuration            time.Duration
		expirePendingTaskDuration   time.Duration
		expireCompletedTaskDuration time.Duration
	}
	convergeTasksReturns struct {
		result1 db.TaskConvergenceResult
	}
	convergeTasksReturnsOnCall map[int]struct {
		result1 db.TaskConvergenceResult
	}
	VersionStub        func(logger lager.Logger) (*models.Version, error)
	versionMutex       sync.RWMutex
	versionArgsForCall []struct {
		logger lager.Logger
	}
	versionReturns struct {
		result1 *models.Version
		result2 error
	}
	versionReturnsOnCall map[int]struct {
		result1 *models.Version
		result2 error
	}
	SetVersionStub        func(logger lager.Logger, version *models.Version) error
	setVersionMutex       sync.RWMutex
	setVersionArgsForCall []struct {
		logger  lager.Logger
		version *models.Version
	}
	setVersionReturns struct {
		result1 error
	}
	setVersionReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveSuspectActualLRPStub        func(lager.Logger, *models.ActualLRPKey) (*models.ActualLRP, error)
	removeSuspectActualLRPMutex       sync.RWMutex
	removeSuspectActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
	}
	removeSuspectActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 error
	}
	removeSuspectActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDB) FreshDomains(logger lager.Logger) ([]string, error) {
	fake.freshDomainsMutex.Lock()
	ret, specificReturn := fake.freshDomainsReturnsOnCall[len(fake.freshDomainsArgsForCall)]
	fake.freshDomainsArgsForCall = append(fake.freshDomainsArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("FreshDomains", []interface{}{logger})
	fake.freshDomainsMutex.Unlock()
	if fake.FreshDomainsStub != nil {
		return fake.FreshDomainsStub(logger)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.freshDomainsReturns.result1, fake.freshDomainsReturns.result2
}

func (fake *FakeDB) FreshDomainsCallCount() int {
	fake.freshDomainsMutex.RLock()
	defer fake.freshDomainsMutex.RUnlock()
	return len(fake.freshDomainsArgsForCall)
}

func (fake *FakeDB) FreshDomainsArgsForCall(i int) lager.Logger {
	fake.freshDomainsMutex.RLock()
	defer fake.freshDomainsMutex.RUnlock()
	return fake.freshDomainsArgsForCall[i].logger
}

func (fake *FakeDB) FreshDomainsReturns(result1 []string, result2 error) {
	fake.FreshDomainsStub = nil
	fake.freshDomainsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) FreshDomainsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.FreshDomainsStub = nil
	if fake.freshDomainsReturnsOnCall == nil {
		fake.freshDomainsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.freshDomainsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) UpsertDomain(lgger lager.Logger, domain string, ttl uint32) error {
	fake.upsertDomainMutex.Lock()
	ret, specificReturn := fake.upsertDomainReturnsOnCall[len(fake.upsertDomainArgsForCall)]
	fake.upsertDomainArgsForCall = append(fake.upsertDomainArgsForCall, struct {
		lgger  lager.Logger
		domain string
		ttl    uint32
	}{lgger, domain, ttl})
	fake.recordInvocation("UpsertDomain", []interface{}{lgger, domain, ttl})
	fake.upsertDomainMutex.Unlock()
	if fake.UpsertDomainStub != nil {
		return fake.UpsertDomainStub(lgger, domain, ttl)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.upsertDomainReturns.result1
}

func (fake *FakeDB) UpsertDomainCallCount() int {
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	return len(fake.upsertDomainArgsForCall)
}

func (fake *FakeDB) UpsertDomainArgsForCall(i int) (lager.Logger, string, uint32) {
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	return fake.upsertDomainArgsForCall[i].lgger, fake.upsertDomainArgsForCall[i].domain, fake.upsertDomainArgsForCall[i].ttl
}

func (fake *FakeDB) UpsertDomainReturns(result1 error) {
	fake.UpsertDomainStub = nil
	fake.upsertDomainReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) UpsertDomainReturnsOnCall(i int, result1 error) {
	fake.UpsertDomainStub = nil
	if fake.upsertDomainReturnsOnCall == nil {
		fake.upsertDomainReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upsertDomainReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) EncryptionKeyLabel(logger lager.Logger) (string, error) {
	fake.encryptionKeyLabelMutex.Lock()
	ret, specificReturn := fake.encryptionKeyLabelReturnsOnCall[len(fake.encryptionKeyLabelArgsForCall)]
	fake.encryptionKeyLabelArgsForCall = append(fake.encryptionKeyLabelArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("EncryptionKeyLabel", []interface{}{logger})
	fake.encryptionKeyLabelMutex.Unlock()
	if fake.EncryptionKeyLabelStub != nil {
		return fake.EncryptionKeyLabelStub(logger)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.encryptionKeyLabelReturns.result1, fake.encryptionKeyLabelReturns.result2
}

func (fake *FakeDB) EncryptionKeyLabelCallCount() int {
	fake.encryptionKeyLabelMutex.RLock()
	defer fake.encryptionKeyLabelMutex.RUnlock()
	return len(fake.encryptionKeyLabelArgsForCall)
}

func (fake *FakeDB) EncryptionKeyLabelArgsForCall(i int) lager.Logger {
	fake.encryptionKeyLabelMutex.RLock()
	defer fake.encryptionKeyLabelMutex.RUnlock()
	return fake.encryptionKeyLabelArgsForCall[i].logger
}

func (fake *FakeDB) EncryptionKeyLabelReturns(result1 string, result2 error) {
	fake.EncryptionKeyLabelStub = nil
	fake.encryptionKeyLabelReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) EncryptionKeyLabelReturnsOnCall(i int, result1 string, result2 error) {
	fake.EncryptionKeyLabelStub = nil
	if fake.encryptionKeyLabelReturnsOnCall == nil {
		fake.encryptionKeyLabelReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.encryptionKeyLabelReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) SetEncryptionKeyLabel(logger lager.Logger, encryptionKeyLabel string) error {
	fake.setEncryptionKeyLabelMutex.Lock()
	ret, specificReturn := fake.setEncryptionKeyLabelReturnsOnCall[len(fake.setEncryptionKeyLabelArgsForCall)]
	fake.setEncryptionKeyLabelArgsForCall = append(fake.setEncryptionKeyLabelArgsForCall, struct {
		logger             lager.Logger
		encryptionKeyLabel string
	}{logger, encryptionKeyLabel})
	fake.recordInvocation("SetEncryptionKeyLabel", []interface{}{logger, encryptionKeyLabel})
	fake.setEncryptionKeyLabelMutex.Unlock()
	if fake.SetEncryptionKeyLabelStub != nil {
		return fake.SetEncryptionKeyLabelStub(logger, encryptionKeyLabel)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setEncryptionKeyLabelReturns.result1
}

func (fake *FakeDB) SetEncryptionKeyLabelCallCount() int {
	fake.setEncryptionKeyLabelMutex.RLock()
	defer fake.setEncryptionKeyLabelMutex.RUnlock()
	return len(fake.setEncryptionKeyLabelArgsForCall)
}

func (fake *FakeDB) SetEncryptionKeyLabelArgsForCall(i int) (lager.Logger, string) {
	fake.setEncryptionKeyLabelMutex.RLock()
	defer fake.setEncryptionKeyLabelMutex.RUnlock()
	return fake.setEncryptionKeyLabelArgsForCall[i].logger, fake.setEncryptionKeyLabelArgsForCall[i].encryptionKeyLabel
}

func (fake *FakeDB) SetEncryptionKeyLabelReturns(result1 error) {
	fake.SetEncryptionKeyLabelStub = nil
	fake.setEncryptionKeyLabelReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) SetEncryptionKeyLabelReturnsOnCall(i int, result1 error) {
	fake.SetEncryptionKeyLabelStub = nil
	if fake.setEncryptionKeyLabelReturnsOnCall == nil {
		fake.setEncryptionKeyLabelReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setEncryptionKeyLabelReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) PerformEncryption(logger lager.Logger) error {
	fake.performEncryptionMutex.Lock()
	ret, specificReturn := fake.performEncryptionReturnsOnCall[len(fake.performEncryptionArgsForCall)]
	fake.performEncryptionArgsForCall = append(fake.performEncryptionArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("PerformEncryption", []interface{}{logger})
	fake.performEncryptionMutex.Unlock()
	if fake.PerformEncryptionStub != nil {
		return fake.PerformEncryptionStub(logger)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.performEncryptionReturns.result1
}

func (fake *FakeDB) PerformEncryptionCallCount() int {
	fake.performEncryptionMutex.RLock()
	defer fake.performEncryptionMutex.RUnlock()
	return len(fake.performEncryptionArgsForCall)
}

func (fake *FakeDB) PerformEncryptionArgsForCall(i int) lager.Logger {
	fake.performEncryptionMutex.RLock()
	defer fake.performEncryptionMutex.RUnlock()
	return fake.performEncryptionArgsForCall[i].logger
}

func (fake *FakeDB) PerformEncryptionReturns(result1 error) {
	fake.PerformEncryptionStub = nil
	fake.performEncryptionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) PerformEncryptionReturnsOnCall(i int, result1 error) {
	fake.PerformEncryptionStub = nil
	if fake.performEncryptionReturnsOnCall == nil {
		fake.performEncryptionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.performEncryptionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) RemoveEvacuatingActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey) error {
	fake.removeEvacuatingActualLRPMutex.Lock()
	ret, specificReturn := fake.removeEvacuatingActualLRPReturnsOnCall[len(fake.removeEvacuatingActualLRPArgsForCall)]
	fake.removeEvacuatingActualLRPArgsForCall = append(fake.removeEvacuatingActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3})
	fake.recordInvocation("RemoveEvacuatingActualLRP", []interface{}{arg1, arg2, arg3})
	fake.removeEvacuatingActualLRPMutex.Unlock()
	if fake.RemoveEvacuatingActualLRPStub != nil {
		return fake.RemoveEvacuatingActualLRPStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeEvacuatingActualLRPReturns.result1
}

func (fake *FakeDB) RemoveEvacuatingActualLRPCallCount() int {
	fake.removeEvacuatingActualLRPMutex.RLock()
	defer fake.removeEvacuatingActualLRPMutex.RUnlock()
	return len(fake.removeEvacuatingActualLRPArgsForCall)
}

func (fake *FakeDB) RemoveEvacuatingActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) {
	fake.removeEvacuatingActualLRPMutex.RLock()
	defer fake.removeEvacuatingActualLRPMutex.RUnlock()
	return fake.removeEvacuatingActualLRPArgsForCall[i].arg1, fake.removeEvacuatingActualLRPArgsForCall[i].arg2, fake.removeEvacuatingActualLRPArgsForCall[i].arg3
}

func (fake *FakeDB) RemoveEvacuatingActualLRPReturns(result1 error) {
	fake.RemoveEvacuatingActualLRPStub = nil
	fake.removeEvacuatingActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) RemoveEvacuatingActualLRPReturnsOnCall(i int, result1 error) {
	fake.RemoveEvacuatingActualLRPStub = nil
	if fake.removeEvacuatingActualLRPReturnsOnCall == nil {
		fake.removeEvacuatingActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeEvacuatingActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) EvacuateActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey, arg4 *models.ActualLRPNetInfo) (actualLRP *models.ActualLRP, err error) {
	fake.evacuateActualLRPMutex.Lock()
	ret, specificReturn := fake.evacuateActualLRPReturnsOnCall[len(fake.evacuateActualLRPArgsForCall)]
	fake.evacuateActualLRPArgsForCall = append(fake.evacuateActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
		arg4 *models.ActualLRPNetInfo
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("EvacuateActualLRP", []interface{}{arg1, arg2, arg3, arg4})
	fake.evacuateActualLRPMutex.Unlock()
	if fake.EvacuateActualLRPStub != nil {
		return fake.EvacuateActualLRPStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.evacuateActualLRPReturns.result1, fake.evacuateActualLRPReturns.result2
}

func (fake *FakeDB) EvacuateActualLRPCallCount() int {
	fake.evacuateActualLRPMutex.RLock()
	defer fake.evacuateActualLRPMutex.RUnlock()
	return len(fake.evacuateActualLRPArgsForCall)
}

func (fake *FakeDB) EvacuateActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) {
	fake.evacuateActualLRPMutex.RLock()
	defer fake.evacuateActualLRPMutex.RUnlock()
	return fake.evacuateActualLRPArgsForCall[i].arg1, fake.evacuateActualLRPArgsForCall[i].arg2, fake.evacuateActualLRPArgsForCall[i].arg3, fake.evacuateActualLRPArgsForCall[i].arg4
}

func (fake *FakeDB) EvacuateActualLRPReturns(result1 *models.ActualLRP, result2 error) {
	fake.EvacuateActualLRPStub = nil
	fake.evacuateActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) EvacuateActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 error) {
	fake.EvacuateActualLRPStub = nil
	if fake.evacuateActualLRPReturnsOnCall == nil {
		fake.evacuateActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 error
		})
	}
	fake.evacuateActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) ActualLRPs(logger lager.Logger, filter models.ActualLRPFilter) ([]*models.ActualLRP, error) {
	fake.actualLRPsMutex.Lock()
	ret, specificReturn := fake.actualLRPsReturnsOnCall[len(fake.actualLRPsArgsForCall)]
	fake.actualLRPsArgsForCall = append(fake.actualLRPsArgsForCall, struct {
		logger lager.Logger
		filter models.ActualLRPFilter
	}{logger, filter})
	fake.recordInvocation("ActualLRPs", []interface{}{logger, filter})
	fake.actualLRPsMutex.Unlock()
	if fake.ActualLRPsStub != nil {
		return fake.ActualLRPsStub(logger, filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.actualLRPsReturns.result1, fake.actualLRPsReturns.result2
}

func (fake *FakeDB) ActualLRPsCallCount() int {
	fake.actualLRPsMutex.RLock()
	defer fake.actualLRPsMutex.RUnlock()
	return len(fake.actualLRPsArgsForCall)
}

func (fake *FakeDB) ActualLRPsArgsForCall(i int) (lager.Logger, models.ActualLRPFilter) {
	fake.actualLRPsMutex.RLock()
	defer fake.actualLRPsMutex.RUnlock()
	return fake.actualLRPsArgsForCall[i].logger, fake.actualLRPsArgsForCall[i].filter
}

func (fake *FakeDB) ActualLRPsReturns(result1 []*models.ActualLRP, result2 error) {
	fake.ActualLRPsStub = nil
	fake.actualLRPsReturns = struct {
		result1 []*models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) ActualLRPsReturnsOnCall(i int, result1 []*models.ActualLRP, result2 error) {
	fake.ActualLRPsStub = nil
	if fake.actualLRPsReturnsOnCall == nil {
		fake.actualLRPsReturnsOnCall = make(map[int]struct {
			result1 []*models.ActualLRP
			result2 error
		})
	}
	fake.actualLRPsReturnsOnCall[i] = struct {
		result1 []*models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) CreateUnclaimedActualLRP(logger lager.Logger, key *models.ActualLRPKey) (after *models.ActualLRP, err error) {
	fake.createUnclaimedActualLRPMutex.Lock()
	ret, specificReturn := fake.createUnclaimedActualLRPReturnsOnCall[len(fake.createUnclaimedActualLRPArgsForCall)]
	fake.createUnclaimedActualLRPArgsForCall = append(fake.createUnclaimedActualLRPArgsForCall, struct {
		logger lager.Logger
		key    *models.ActualLRPKey
	}{logger, key})
	fake.recordInvocation("CreateUnclaimedActualLRP", []interface{}{logger, key})
	fake.createUnclaimedActualLRPMutex.Unlock()
	if fake.CreateUnclaimedActualLRPStub != nil {
		return fake.CreateUnclaimedActualLRPStub(logger, key)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createUnclaimedActualLRPReturns.result1, fake.createUnclaimedActualLRPReturns.result2
}

func (fake *FakeDB) CreateUnclaimedActualLRPCallCount() int {
	fake.createUnclaimedActualLRPMutex.RLock()
	defer fake.createUnclaimedActualLRPMutex.RUnlock()
	return len(fake.createUnclaimedActualLRPArgsForCall)
}

func (fake *FakeDB) CreateUnclaimedActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey) {
	fake.createUnclaimedActualLRPMutex.RLock()
	defer fake.createUnclaimedActualLRPMutex.RUnlock()
	return fake.createUnclaimedActualLRPArgsForCall[i].logger, fake.createUnclaimedActualLRPArgsForCall[i].key
}

func (fake *FakeDB) CreateUnclaimedActualLRPReturns(result1 *models.ActualLRP, result2 error) {
	fake.CreateUnclaimedActualLRPStub = nil
	fake.createUnclaimedActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) CreateUnclaimedActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 error) {
	fake.CreateUnclaimedActualLRPStub = nil
	if fake.createUnclaimedActualLRPReturnsOnCall == nil {
		fake.createUnclaimedActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 error
		})
	}
	fake.createUnclaimedActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) UnclaimActualLRP(logger lager.Logger, key *models.ActualLRPKey) (before *models.ActualLRP, after *models.ActualLRP, err error) {
	fake.unclaimActualLRPMutex.Lock()
	ret, specificReturn := fake.unclaimActualLRPReturnsOnCall[len(fake.unclaimActualLRPArgsForCall)]
	fake.unclaimActualLRPArgsForCall = append(fake.unclaimActualLRPArgsForCall, struct {
		logger lager.Logger
		key    *models.ActualLRPKey
	}{logger, key})
	fake.recordInvocation("UnclaimActualLRP", []interface{}{logger, key})
	fake.unclaimActualLRPMutex.Unlock()
	if fake.UnclaimActualLRPStub != nil {
		return fake.UnclaimActualLRPStub(logger, key)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.unclaimActualLRPReturns.result1, fake.unclaimActualLRPReturns.result2, fake.unclaimActualLRPReturns.result3
}

func (fake *FakeDB) UnclaimActualLRPCallCount() int {
	fake.unclaimActualLRPMutex.RLock()
	defer fake.unclaimActualLRPMutex.RUnlock()
	return len(fake.unclaimActualLRPArgsForCall)
}

func (fake *FakeDB) UnclaimActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey) {
	fake.unclaimActualLRPMutex.RLock()
	defer fake.unclaimActualLRPMutex.RUnlock()
	return fake.unclaimActualLRPArgsForCall[i].logger, fake.unclaimActualLRPArgsForCall[i].key
}

func (fake *FakeDB) UnclaimActualLRPReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.UnclaimActualLRPStub = nil
	fake.unclaimActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) UnclaimActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.UnclaimActualLRPStub = nil
	if fake.unclaimActualLRPReturnsOnCall == nil {
		fake.unclaimActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 error
		})
	}
	fake.unclaimActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) ClaimActualLRP(logger lager.Logger, processGuid string, index int32, instanceKey *models.ActualLRPInstanceKey) (before *models.ActualLRP, after *models.ActualLRP, err error) {
	fake.claimActualLRPMutex.Lock()
	ret, specificReturn := fake.claimActualLRPReturnsOnCall[len(fake.claimActualLRPArgsForCall)]
	fake.claimActualLRPArgsForCall = append(fake.claimActualLRPArgsForCall, struct {
		logger      lager.Logger
		processGuid string
		index       int32
		instanceKey *models.ActualLRPInstanceKey
	}{logger, processGuid, index, instanceKey})
	fake.recordInvocation("ClaimActualLRP", []interface{}{logger, processGuid, index, instanceKey})
	fake.claimActualLRPMutex.Unlock()
	if fake.ClaimActualLRPStub != nil {
		return fake.ClaimActualLRPStub(logger, processGuid, index, instanceKey)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.claimActualLRPReturns.result1, fake.claimActualLRPReturns.result2, fake.claimActualLRPReturns.result3
}

func (fake *FakeDB) ClaimActualLRPCallCount() int {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	return len(fake.claimActualLRPArgsForCall)
}

func (fake *FakeDB) ClaimActualLRPArgsForCall(i int) (lager.Logger, string, int32, *models.ActualLRPInstanceKey) {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	return fake.claimActualLRPArgsForCall[i].logger, fake.claimActualLRPArgsForCall[i].processGuid, fake.claimActualLRPArgsForCall[i].index, fake.claimActualLRPArgsForCall[i].instanceKey
}

func (fake *FakeDB) ClaimActualLRPReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.ClaimActualLRPStub = nil
	fake.claimActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) ClaimActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.ClaimActualLRPStub = nil
	if fake.claimActualLRPReturnsOnCall == nil {
		fake.claimActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 error
		})
	}
	fake.claimActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) StartActualLRP(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, netInfo *models.ActualLRPNetInfo) (before *models.ActualLRP, after *models.ActualLRP, err error) {
	fake.startActualLRPMutex.Lock()
	ret, specificReturn := fake.startActualLRPReturnsOnCall[len(fake.startActualLRPArgsForCall)]
	fake.startActualLRPArgsForCall = append(fake.startActualLRPArgsForCall, struct {
		logger      lager.Logger
		key         *models.ActualLRPKey
		instanceKey *models.ActualLRPInstanceKey
		netInfo     *models.ActualLRPNetInfo
	}{logger, key, instanceKey, netInfo})
	fake.recordInvocation("StartActualLRP", []interface{}{logger, key, instanceKey, netInfo})
	fake.startActualLRPMutex.Unlock()
	if fake.StartActualLRPStub != nil {
		return fake.StartActualLRPStub(logger, key, instanceKey, netInfo)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.startActualLRPReturns.result1, fake.startActualLRPReturns.result2, fake.startActualLRPReturns.result3
}

func (fake *FakeDB) StartActualLRPCallCount() int {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	return len(fake.startActualLRPArgsForCall)
}

func (fake *FakeDB) StartActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	return fake.startActualLRPArgsForCall[i].logger, fake.startActualLRPArgsForCall[i].key, fake.startActualLRPArgsForCall[i].instanceKey, fake.startActualLRPArgsForCall[i].netInfo
}

func (fake *FakeDB) StartActualLRPReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.StartActualLRPStub = nil
	fake.startActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) StartActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.StartActualLRPStub = nil
	if fake.startActualLRPReturnsOnCall == nil {
		fake.startActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 error
		})
	}
	fake.startActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) CrashActualLRP(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, crashReason string) (before *models.ActualLRP, after *models.ActualLRP, shouldRestart bool, err error) {
	fake.crashActualLRPMutex.Lock()
	ret, specificReturn := fake.crashActualLRPReturnsOnCall[len(fake.crashActualLRPArgsForCall)]
	fake.crashActualLRPArgsForCall = append(fake.crashActualLRPArgsForCall, struct {
		logger      lager.Logger
		key         *models.ActualLRPKey
		instanceKey *models.ActualLRPInstanceKey
		crashReason string
	}{logger, key, instanceKey, crashReason})
	fake.recordInvocation("CrashActualLRP", []interface{}{logger, key, instanceKey, crashReason})
	fake.crashActualLRPMutex.Unlock()
	if fake.CrashActualLRPStub != nil {
		return fake.CrashActualLRPStub(logger, key, instanceKey, crashReason)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fake.crashActualLRPReturns.result1, fake.crashActualLRPReturns.result2, fake.crashActualLRPReturns.result3, fake.crashActualLRPReturns.result4
}

func (fake *FakeDB) CrashActualLRPCallCount() int {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	return len(fake.crashActualLRPArgsForCall)
}

func (fake *FakeDB) CrashActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	return fake.crashActualLRPArgsForCall[i].logger, fake.crashActualLRPArgsForCall[i].key, fake.crashActualLRPArgsForCall[i].instanceKey, fake.crashActualLRPArgsForCall[i].crashReason
}

func (fake *FakeDB) CrashActualLRPReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 bool, result4 error) {
	fake.CrashActualLRPStub = nil
	fake.crashActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeDB) CrashActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 bool, result4 error) {
	fake.CrashActualLRPStub = nil
	if fake.crashActualLRPReturnsOnCall == nil {
		fake.crashActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 bool
			result4 error
		})
	}
	fake.crashActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeDB) FailActualLRP(logger lager.Logger, key *models.ActualLRPKey, placementError string) (before *models.ActualLRP, after *models.ActualLRP, err error) {
	fake.failActualLRPMutex.Lock()
	ret, specificReturn := fake.failActualLRPReturnsOnCall[len(fake.failActualLRPArgsForCall)]
	fake.failActualLRPArgsForCall = append(fake.failActualLRPArgsForCall, struct {
		logger         lager.Logger
		key            *models.ActualLRPKey
		placementError string
	}{logger, key, placementError})
	fake.recordInvocation("FailActualLRP", []interface{}{logger, key, placementError})
	fake.failActualLRPMutex.Unlock()
	if fake.FailActualLRPStub != nil {
		return fake.FailActualLRPStub(logger, key, placementError)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.failActualLRPReturns.result1, fake.failActualLRPReturns.result2, fake.failActualLRPReturns.result3
}

func (fake *FakeDB) FailActualLRPCallCount() int {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	return len(fake.failActualLRPArgsForCall)
}

func (fake *FakeDB) FailActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, string) {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	return fake.failActualLRPArgsForCall[i].logger, fake.failActualLRPArgsForCall[i].key, fake.failActualLRPArgsForCall[i].placementError
}

func (fake *FakeDB) FailActualLRPReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.FailActualLRPStub = nil
	fake.failActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) FailActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.FailActualLRPStub = nil
	if fake.failActualLRPReturnsOnCall == nil {
		fake.failActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 error
		})
	}
	fake.failActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) RemoveActualLRP(logger lager.Logger, processGuid string, index int32, instanceKey *models.ActualLRPInstanceKey) error {
	fake.removeActualLRPMutex.Lock()
	ret, specificReturn := fake.removeActualLRPReturnsOnCall[len(fake.removeActualLRPArgsForCall)]
	fake.removeActualLRPArgsForCall = append(fake.removeActualLRPArgsForCall, struct {
		logger      lager.Logger
		processGuid string
		index       int32
		instanceKey *models.ActualLRPInstanceKey
	}{logger, processGuid, index, instanceKey})
	fake.recordInvocation("RemoveActualLRP", []interface{}{logger, processGuid, index, instanceKey})
	fake.removeActualLRPMutex.Unlock()
	if fake.RemoveActualLRPStub != nil {
		return fake.RemoveActualLRPStub(logger, processGuid, index, instanceKey)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeActualLRPReturns.result1
}

func (fake *FakeDB) RemoveActualLRPCallCount() int {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	return len(fake.removeActualLRPArgsForCall)
}

func (fake *FakeDB) RemoveActualLRPArgsForCall(i int) (lager.Logger, string, int32, *models.ActualLRPInstanceKey) {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	return fake.removeActualLRPArgsForCall[i].logger, fake.removeActualLRPArgsForCall[i].processGuid, fake.removeActualLRPArgsForCall[i].index, fake.removeActualLRPArgsForCall[i].instanceKey
}

func (fake *FakeDB) RemoveActualLRPReturns(result1 error) {
	fake.RemoveActualLRPStub = nil
	fake.removeActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) RemoveActualLRPReturnsOnCall(i int, result1 error) {
	fake.RemoveActualLRPStub = nil
	if fake.removeActualLRPReturnsOnCall == nil {
		fake.removeActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) ChangeActualLRPPresence(logger lager.Logger, key *models.ActualLRPKey, from models.ActualLRP_Presence, to models.ActualLRP_Presence) (before *models.ActualLRP, after *models.ActualLRP, err error) {
	fake.changeActualLRPPresenceMutex.Lock()
	ret, specificReturn := fake.changeActualLRPPresenceReturnsOnCall[len(fake.changeActualLRPPresenceArgsForCall)]
	fake.changeActualLRPPresenceArgsForCall = append(fake.changeActualLRPPresenceArgsForCall, struct {
		logger lager.Logger
		key    *models.ActualLRPKey
		from   models.ActualLRP_Presence
		to     models.ActualLRP_Presence
	}{logger, key, from, to})
	fake.recordInvocation("ChangeActualLRPPresence", []interface{}{logger, key, from, to})
	fake.changeActualLRPPresenceMutex.Unlock()
	if fake.ChangeActualLRPPresenceStub != nil {
		return fake.ChangeActualLRPPresenceStub(logger, key, from, to)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.changeActualLRPPresenceReturns.result1, fake.changeActualLRPPresenceReturns.result2, fake.changeActualLRPPresenceReturns.result3
}

func (fake *FakeDB) ChangeActualLRPPresenceCallCount() int {
	fake.changeActualLRPPresenceMutex.RLock()
	defer fake.changeActualLRPPresenceMutex.RUnlock()
	return len(fake.changeActualLRPPresenceArgsForCall)
}

func (fake *FakeDB) ChangeActualLRPPresenceArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, models.ActualLRP_Presence, models.ActualLRP_Presence) {
	fake.changeActualLRPPresenceMutex.RLock()
	defer fake.changeActualLRPPresenceMutex.RUnlock()
	return fake.changeActualLRPPresenceArgsForCall[i].logger, fake.changeActualLRPPresenceArgsForCall[i].key, fake.changeActualLRPPresenceArgsForCall[i].from, fake.changeActualLRPPresenceArgsForCall[i].to
}

func (fake *FakeDB) ChangeActualLRPPresenceReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.ChangeActualLRPPresenceStub = nil
	fake.changeActualLRPPresenceReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) ChangeActualLRPPresenceReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.ChangeActualLRPPresenceStub = nil
	if fake.changeActualLRPPresenceReturnsOnCall == nil {
		fake.changeActualLRPPresenceReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 error
		})
	}
	fake.changeActualLRPPresenceReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) CountActualLRPsByState(logger lager.Logger) (int, int, int, int, int) {
	fake.countActualLRPsByStateMutex.Lock()
	ret, specificReturn := fake.countActualLRPsByStateReturnsOnCall[len(fake.countActualLRPsByStateArgsForCall)]
	fake.countActualLRPsByStateArgsForCall = append(fake.countActualLRPsByStateArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("CountActualLRPsByState", []interface{}{logger})
	fake.countActualLRPsByStateMutex.Unlock()
	if fake.CountActualLRPsByStateStub != nil {
		return fake.CountActualLRPsByStateStub(logger)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4, ret.result5
	}
	return fake.countActualLRPsByStateReturns.result1, fake.countActualLRPsByStateReturns.result2, fake.countActualLRPsByStateReturns.result3, fake.countActualLRPsByStateReturns.result4, fake.countActualLRPsByStateReturns.result5
}

func (fake *FakeDB) CountActualLRPsByStateCallCount() int {
	fake.countActualLRPsByStateMutex.RLock()
	defer fake.countActualLRPsByStateMutex.RUnlock()
	return len(fake.countActualLRPsByStateArgsForCall)
}

func (fake *FakeDB) CountActualLRPsByStateArgsForCall(i int) lager.Logger {
	fake.countActualLRPsByStateMutex.RLock()
	defer fake.countActualLRPsByStateMutex.RUnlock()
	return fake.countActualLRPsByStateArgsForCall[i].logger
}

func (fake *FakeDB) CountActualLRPsByStateReturns(result1 int, result2 int, result3 int, result4 int, result5 int) {
	fake.CountActualLRPsByStateStub = nil
	fake.countActualLRPsByStateReturns = struct {
		result1 int
		result2 int
		result3 int
		result4 int
		result5 int
	}{result1, result2, result3, result4, result5}
}

func (fake *FakeDB) CountActualLRPsByStateReturnsOnCall(i int, result1 int, result2 int, result3 int, result4 int, result5 int) {
	fake.CountActualLRPsByStateStub = nil
	if fake.countActualLRPsByStateReturnsOnCall == nil {
		fake.countActualLRPsByStateReturnsOnCall = make(map[int]struct {
			result1 int
			result2 int
			result3 int
			result4 int
			result5 int
		})
	}
	fake.countActualLRPsByStateReturnsOnCall[i] = struct {
		result1 int
		result2 int
		result3 int
		result4 int
		result5 int
	}{result1, result2, result3, result4, result5}
}

func (fake *FakeDB) CountDesiredInstances(logger lager.Logger) int {
	fake.countDesiredInstancesMutex.Lock()
	ret, specificReturn := fake.countDesiredInstancesReturnsOnCall[len(fake.countDesiredInstancesArgsForCall)]
	fake.countDesiredInstancesArgsForCall = append(fake.countDesiredInstancesArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("CountDesiredInstances", []interface{}{logger})
	fake.countDesiredInstancesMutex.Unlock()
	if fake.CountDesiredInstancesStub != nil {
		return fake.CountDesiredInstancesStub(logger)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.countDesiredInstancesReturns.result1
}

func (fake *FakeDB) CountDesiredInstancesCallCount() int {
	fake.countDesiredInstancesMutex.RLock()
	defer fake.countDesiredInstancesMutex.RUnlock()
	return len(fake.countDesiredInstancesArgsForCall)
}

func (fake *FakeDB) CountDesiredInstancesArgsForCall(i int) lager.Logger {
	fake.countDesiredInstancesMutex.RLock()
	defer fake.countDesiredInstancesMutex.RUnlock()
	return fake.countDesiredInstancesArgsForCall[i].logger
}

func (fake *FakeDB) CountDesiredInstancesReturns(result1 int) {
	fake.CountDesiredInstancesStub = nil
	fake.countDesiredInstancesReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeDB) CountDesiredInstancesReturnsOnCall(i int, result1 int) {
	fake.CountDesiredInstancesStub = nil
	if fake.countDesiredInstancesReturnsOnCall == nil {
		fake.countDesiredInstancesReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.countDesiredInstancesReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeDB) DesiredLRPs(logger lager.Logger, filter models.DesiredLRPFilter) ([]*models.DesiredLRP, error) {
	fake.desiredLRPsMutex.Lock()
	ret, specificReturn := fake.desiredLRPsReturnsOnCall[len(fake.desiredLRPsArgsForCall)]
	fake.desiredLRPsArgsForCall = append(fake.desiredLRPsArgsForCall, struct {
		logger lager.Logger
		filter models.DesiredLRPFilter
	}{logger, filter})
	fake.recordInvocation("DesiredLRPs", []interface{}{logger, filter})
	fake.desiredLRPsMutex.Unlock()
	if fake.DesiredLRPsStub != nil {
		return fake.DesiredLRPsStub(logger, filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.desiredLRPsReturns.result1, fake.desiredLRPsReturns.result2
}

func (fake *FakeDB) DesiredLRPsCallCount() int {
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	return len(fake.desiredLRPsArgsForCall)
}

func (fake *FakeDB) DesiredLRPsArgsForCall(i int) (lager.Logger, models.DesiredLRPFilter) {
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	return fake.desiredLRPsArgsForCall[i].logger, fake.desiredLRPsArgsForCall[i].filter
}

func (fake *FakeDB) DesiredLRPsReturns(result1 []*models.DesiredLRP, result2 error) {
	fake.DesiredLRPsStub = nil
	fake.desiredLRPsReturns = struct {
		result1 []*models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DesiredLRPsReturnsOnCall(i int, result1 []*models.DesiredLRP, result2 error) {
	fake.DesiredLRPsStub = nil
	if fake.desiredLRPsReturnsOnCall == nil {
		fake.desiredLRPsReturnsOnCall = make(map[int]struct {
			result1 []*models.DesiredLRP
			result2 error
		})
	}
	fake.desiredLRPsReturnsOnCall[i] = struct {
		result1 []*models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DesiredLRPByProcessGuid(logger lager.Logger, processGuid string) (*models.DesiredLRP, error) {
	fake.desiredLRPByProcessGuidMutex.Lock()
	ret, specificReturn := fake.desiredLRPByProcessGuidReturnsOnCall[len(fake.desiredLRPByProcessGuidArgsForCall)]
	fake.desiredLRPByProcessGuidArgsForCall = append(fake.desiredLRPByProcessGuidArgsForCall, struct {
		logger      lager.Logger
		processGuid string
	}{logger, processGuid})
	fake.recordInvocation("DesiredLRPByProcessGuid", []interface{}{logger, processGuid})
	fake.desiredLRPByProcessGuidMutex.Unlock()
	if fake.DesiredLRPByProcessGuidStub != nil {
		return fake.DesiredLRPByProcessGuidStub(logger, processGuid)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.desiredLRPByProcessGuidReturns.result1, fake.desiredLRPByProcessGuidReturns.result2
}

func (fake *FakeDB) DesiredLRPByProcessGuidCallCount() int {
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	return len(fake.desiredLRPByProcessGuidArgsForCall)
}

func (fake *FakeDB) DesiredLRPByProcessGuidArgsForCall(i int) (lager.Logger, string) {
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	return fake.desiredLRPByProcessGuidArgsForCall[i].logger, fake.desiredLRPByProcessGuidArgsForCall[i].processGuid
}

func (fake *FakeDB) DesiredLRPByProcessGuidReturns(result1 *models.DesiredLRP, result2 error) {
	fake.DesiredLRPByProcessGuidStub = nil
	fake.desiredLRPByProcessGuidReturns = struct {
		result1 *models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DesiredLRPByProcessGuidReturnsOnCall(i int, result1 *models.DesiredLRP, result2 error) {
	fake.DesiredLRPByProcessGuidStub = nil
	if fake.desiredLRPByProcessGuidReturnsOnCall == nil {
		fake.desiredLRPByProcessGuidReturnsOnCall = make(map[int]struct {
			result1 *models.DesiredLRP
			result2 error
		})
	}
	fake.desiredLRPByProcessGuidReturnsOnCall[i] = struct {
		result1 *models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DesiredLRPSchedulingInfos(logger lager.Logger, filter models.DesiredLRPFilter) ([]*models.DesiredLRPSchedulingInfo, error) {
	fake.desiredLRPSchedulingInfosMutex.Lock()
	ret, specificReturn := fake.desiredLRPSchedulingInfosReturnsOnCall[len(fake.desiredLRPSchedulingInfosArgsForCall)]
	fake.desiredLRPSchedulingInfosArgsForCall = append(fake.desiredLRPSchedulingInfosArgsForCall, struct {
		logger lager.Logger
		filter models.DesiredLRPFilter
	}{logger, filter})
	fake.recordInvocation("DesiredLRPSchedulingInfos", []interface{}{logger, filter})
	fake.desiredLRPSchedulingInfosMutex.Unlock()
	if fake.DesiredLRPSchedulingInfosStub != nil {
		return fake.DesiredLRPSchedulingInfosStub(logger, filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.desiredLRPSchedulingInfosReturns.result1, fake.desiredLRPSchedulingInfosReturns.result2
}

func (fake *FakeDB) DesiredLRPSchedulingInfosCallCount() int {
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	return len(fake.desiredLRPSchedulingInfosArgsForCall)
}

func (fake *FakeDB) DesiredLRPSchedulingInfosArgsForCall(i int) (lager.Logger, models.DesiredLRPFilter) {
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	return fake.desiredLRPSchedulingInfosArgsForCall[i].logger, fake.desiredLRPSchedulingInfosArgsForCall[i].filter
}

func (fake *FakeDB) DesiredLRPSchedulingInfosReturns(result1 []*models.DesiredLRPSchedulingInfo, result2 error) {
	fake.DesiredLRPSchedulingInfosStub = nil
	fake.desiredLRPSchedulingInfosReturns = struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DesiredLRPSchedulingInfosReturnsOnCall(i int, result1 []*models.DesiredLRPSchedulingInfo, result2 error) {
	fake.DesiredLRPSchedulingInfosStub = nil
	if fake.desiredLRPSchedulingInfosReturnsOnCall == nil {
		fake.desiredLRPSchedulingInfosReturnsOnCall = make(map[int]struct {
			result1 []*models.DesiredLRPSchedulingInfo
			result2 error
		})
	}
	fake.desiredLRPSchedulingInfosReturnsOnCall[i] = struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DesireLRP(logger lager.Logger, desiredLRP *models.DesiredLRP) error {
	fake.desireLRPMutex.Lock()
	ret, specificReturn := fake.desireLRPReturnsOnCall[len(fake.desireLRPArgsForCall)]
	fake.desireLRPArgsForCall = append(fake.desireLRPArgsForCall, struct {
		logger     lager.Logger
		desiredLRP *models.DesiredLRP
	}{logger, desiredLRP})
	fake.recordInvocation("DesireLRP", []interface{}{logger, desiredLRP})
	fake.desireLRPMutex.Unlock()
	if fake.DesireLRPStub != nil {
		return fake.DesireLRPStub(logger, desiredLRP)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.desireLRPReturns.result1
}

func (fake *FakeDB) DesireLRPCallCount() int {
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	return len(fake.desireLRPArgsForCall)
}

func (fake *FakeDB) DesireLRPArgsForCall(i int) (lager.Logger, *models.DesiredLRP) {
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	return fake.desireLRPArgsForCall[i].logger, fake.desireLRPArgsForCall[i].desiredLRP
}

func (fake *FakeDB) DesireLRPReturns(result1 error) {
	fake.DesireLRPStub = nil
	fake.desireLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) DesireLRPReturnsOnCall(i int, result1 error) {
	fake.DesireLRPStub = nil
	if fake.desireLRPReturnsOnCall == nil {
		fake.desireLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.desireLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) UpdateDesiredLRP(logger lager.Logger, processGuid string, update *models.DesiredLRPUpdate) (beforeDesiredLRP *models.DesiredLRP, err error) {
	fake.updateDesiredLRPMutex.Lock()
	ret, specificReturn := fake.updateDesiredLRPReturnsOnCall[len(fake.updateDesiredLRPArgsForCall)]
	fake.updateDesiredLRPArgsForCall = append(fake.updateDesiredLRPArgsForCall, struct {
		logger      lager.Logger
		processGuid string
		update      *models.DesiredLRPUpdate
	}{logger, processGuid, update})
	fake.recordInvocation("UpdateDesiredLRP", []interface{}{logger, processGuid, update})
	fake.updateDesiredLRPMutex.Unlock()
	if fake.UpdateDesiredLRPStub != nil {
		return fake.UpdateDesiredLRPStub(logger, processGuid, update)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updateDesiredLRPReturns.result1, fake.updateDesiredLRPReturns.result2
}

func (fake *FakeDB) UpdateDesiredLRPCallCount() int {
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	return len(fake.updateDesiredLRPArgsForCall)
}

func (fake *FakeDB) UpdateDesiredLRPArgsForCall(i int) (lager.Logger, string, *models.DesiredLRPUpdate) {
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	return fake.updateDesiredLRPArgsForCall[i].logger, fake.updateDesiredLRPArgsForCall[i].processGuid, fake.updateDesiredLRPArgsForCall[i].update
}

func (fake *FakeDB) UpdateDesiredLRPReturns(result1 *models.DesiredLRP, result2 error) {
	fake.UpdateDesiredLRPStub = nil
	fake.updateDesiredLRPReturns = struct {
		result1 *models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) UpdateDesiredLRPReturnsOnCall(i int, result1 *models.DesiredLRP, result2 error) {
	fake.UpdateDesiredLRPStub = nil
	if fake.updateDesiredLRPReturnsOnCall == nil {
		fake.updateDesiredLRPReturnsOnCall = make(map[int]struct {
			result1 *models.DesiredLRP
			result2 error
		})
	}
	fake.updateDesiredLRPReturnsOnCall[i] = struct {
		result1 *models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) RemoveDesiredLRP(logger lager.Logger, processGuid string) error {
	fake.removeDesiredLRPMutex.Lock()
	ret, specificReturn := fake.removeDesiredLRPReturnsOnCall[len(fake.removeDesiredLRPArgsForCall)]
	fake.removeDesiredLRPArgsForCall = append(fake.removeDesiredLRPArgsForCall, struct {
		logger      lager.Logger
		processGuid string
	}{logger, processGuid})
	fake.recordInvocation("RemoveDesiredLRP", []interface{}{logger, processGuid})
	fake.removeDesiredLRPMutex.Unlock()
	if fake.RemoveDesiredLRPStub != nil {
		return fake.RemoveDesiredLRPStub(logger, processGuid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeDesiredLRPReturns.result1
}

func (fake *FakeDB) RemoveDesiredLRPCallCount() int {
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	return len(fake.removeDesiredLRPArgsForCall)
}

func (fake *FakeDB) RemoveDesiredLRPArgsForCall(i int) (lager.Logger, string) {
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	return fake.removeDesiredLRPArgsForCall[i].logger, fake.removeDesiredLRPArgsForCall[i].processGuid
}

func (fake *FakeDB) RemoveDesiredLRPReturns(result1 error) {
	fake.RemoveDesiredLRPStub = nil
	fake.removeDesiredLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) RemoveDesiredLRPReturnsOnCall(i int, result1 error) {
	fake.RemoveDesiredLRPStub = nil
	if fake.removeDesiredLRPReturnsOnCall == nil {
		fake.removeDesiredLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeDesiredLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) ConvergeLRPs(logger lager.Logger, cellSet models.CellSet) db.ConvergenceResult {
	fake.convergeLRPsMutex.Lock()
	ret, specificReturn := fake.convergeLRPsReturnsOnCall[len(fake.convergeLRPsArgsForCall)]
	fake.convergeLRPsArgsForCall = append(fake.convergeLRPsArgsForCall, struct {
		logger  lager.Logger
		cellSet models.CellSet
	}{logger, cellSet})
	fake.recordInvocation("ConvergeLRPs", []interface{}{logger, cellSet})
	fake.convergeLRPsMutex.Unlock()
	if fake.ConvergeLRPsStub != nil {
		return fake.ConvergeLRPsStub(logger, cellSet)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.convergeLRPsReturns.result1
}

func (fake *FakeDB) ConvergeLRPsCallCount() int {
	fake.convergeLRPsMutex.RLock()
	defer fake.convergeLRPsMutex.RUnlock()
	return len(fake.convergeLRPsArgsForCall)
}

func (fake *FakeDB) ConvergeLRPsArgsForCall(i int) (lager.Logger, models.CellSet) {
	fake.convergeLRPsMutex.RLock()
	defer fake.convergeLRPsMutex.RUnlock()
	return fake.convergeLRPsArgsForCall[i].logger, fake.convergeLRPsArgsForCall[i].cellSet
}

func (fake *FakeDB) ConvergeLRPsReturns(result1 db.ConvergenceResult) {
	fake.ConvergeLRPsStub = nil
	fake.convergeLRPsReturns = struct {
		result1 db.ConvergenceResult
	}{result1}
}

func (fake *FakeDB) ConvergeLRPsReturnsOnCall(i int, result1 db.ConvergenceResult) {
	fake.ConvergeLRPsStub = nil
	if fake.convergeLRPsReturnsOnCall == nil {
		fake.convergeLRPsReturnsOnCall = make(map[int]struct {
			result1 db.ConvergenceResult
		})
	}
	fake.convergeLRPsReturnsOnCall[i] = struct {
		result1 db.ConvergenceResult
	}{result1}
}

func (fake *FakeDB) Tasks(logger lager.Logger, filter models.TaskFilter) ([]*models.Task, error) {
	fake.tasksMutex.Lock()
	ret, specificReturn := fake.tasksReturnsOnCall[len(fake.tasksArgsForCall)]
	fake.tasksArgsForCall = append(fake.tasksArgsForCall, struct {
		logger lager.Logger
		filter models.TaskFilter
	}{logger, filter})
	fake.recordInvocation("Tasks", []interface{}{logger, filter})
	fake.tasksMutex.Unlock()
	if fake.TasksStub != nil {
		return fake.TasksStub(logger, filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.tasksReturns.result1, fake.tasksReturns.result2
}

func (fake *FakeDB) TasksCallCount() int {
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	return len(fake.tasksArgsForCall)
}

func (fake *FakeDB) TasksArgsForCall(i int) (lager.Logger, models.TaskFilter) {
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	return fake.tasksArgsForCall[i].logger, fake.tasksArgsForCall[i].filter
}

func (fake *FakeDB) TasksReturns(result1 []*models.Task, result2 error) {
	fake.TasksStub = nil
	fake.tasksReturns = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) TasksReturnsOnCall(i int, result1 []*models.Task, result2 error) {
	fake.TasksStub = nil
	if fake.tasksReturnsOnCall == nil {
		fake.tasksReturnsOnCall = make(map[int]struct {
			result1 []*models.Task
			result2 error
		})
	}
	fake.tasksReturnsOnCall[i] = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) TaskByGuid(logger lager.Logger, taskGuid string) (*models.Task, error) {
	fake.taskByGuidMutex.Lock()
	ret, specificReturn := fake.taskByGuidReturnsOnCall[len(fake.taskByGuidArgsForCall)]
	fake.taskByGuidArgsForCall = append(fake.taskByGuidArgsForCall, struct {
		logger   lager.Logger
		taskGuid string
	}{logger, taskGuid})
	fake.recordInvocation("TaskByGuid", []interface{}{logger, taskGuid})
	fake.taskByGuidMutex.Unlock()
	if fake.TaskByGuidStub != nil {
		return fake.TaskByGuidStub(logger, taskGuid)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.taskByGuidReturns.result1, fake.taskByGuidReturns.result2
}

func (fake *FakeDB) TaskByGuidCallCount() int {
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	return len(fake.taskByGuidArgsForCall)
}

func (fake *FakeDB) TaskByGuidArgsForCall(i int) (lager.Logger, string) {
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	return fake.taskByGuidArgsForCall[i].logger, fake.taskByGuidArgsForCall[i].taskGuid
}

func (fake *FakeDB) TaskByGuidReturns(result1 *models.Task, result2 error) {
	fake.TaskByGuidStub = nil
	fake.taskByGuidReturns = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) TaskByGuidReturnsOnCall(i int, result1 *models.Task, result2 error) {
	fake.TaskByGuidStub = nil
	if fake.taskByGuidReturnsOnCall == nil {
		fake.taskByGuidReturnsOnCall = make(map[int]struct {
			result1 *models.Task
			result2 error
		})
	}
	fake.taskByGuidReturnsOnCall[i] = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DesireTask(logger lager.Logger, taskDefinition *models.TaskDefinition, taskGuid string, domain string) (*models.Task, error) {
	fake.desireTaskMutex.Lock()
	ret, specificReturn := fake.desireTaskReturnsOnCall[len(fake.desireTaskArgsForCall)]
	fake.desireTaskArgsForCall = append(fake.desireTaskArgsForCall, struct {
		logger         lager.Logger
		taskDefinition *models.TaskDefinition
		taskGuid       string
		domain         string
	}{logger, taskDefinition, taskGuid, domain})
	fake.recordInvocation("DesireTask", []interface{}{logger, taskDefinition, taskGuid, domain})
	fake.desireTaskMutex.Unlock()
	if fake.DesireTaskStub != nil {
		return fake.DesireTaskStub(logger, taskDefinition, taskGuid, domain)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.desireTaskReturns.result1, fake.desireTaskReturns.result2
}

func (fake *FakeDB) DesireTaskCallCount() int {
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	return len(fake.desireTaskArgsForCall)
}

func (fake *FakeDB) DesireTaskArgsForCall(i int) (lager.Logger, *models.TaskDefinition, string, string) {
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	return fake.desireTaskArgsForCall[i].logger, fake.desireTaskArgsForCall[i].taskDefinition, fake.desireTaskArgsForCall[i].taskGuid, fake.desireTaskArgsForCall[i].domain
}

func (fake *FakeDB) DesireTaskReturns(result1 *models.Task, result2 error) {
	fake.DesireTaskStub = nil
	fake.desireTaskReturns = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DesireTaskReturnsOnCall(i int, result1 *models.Task, result2 error) {
	fake.DesireTaskStub = nil
	if fake.desireTaskReturnsOnCall == nil {
		fake.desireTaskReturnsOnCall = make(map[int]struct {
			result1 *models.Task
			result2 error
		})
	}
	fake.desireTaskReturnsOnCall[i] = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) StartTask(logger lager.Logger, taskGuid string, cellId string) (before *models.Task, after *models.Task, shouldStart bool, rr error) {
	fake.startTaskMutex.Lock()
	ret, specificReturn := fake.startTaskReturnsOnCall[len(fake.startTaskArgsForCall)]
	fake.startTaskArgsForCall = append(fake.startTaskArgsForCall, struct {
		logger   lager.Logger
		taskGuid string
		cellId   string
	}{logger, taskGuid, cellId})
	fake.recordInvocation("StartTask", []interface{}{logger, taskGuid, cellId})
	fake.startTaskMutex.Unlock()
	if fake.StartTaskStub != nil {
		return fake.StartTaskStub(logger, taskGuid, cellId)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fake.startTaskReturns.result1, fake.startTaskReturns.result2, fake.startTaskReturns.result3, fake.startTaskReturns.result4
}

func (fake *FakeDB) StartTaskCallCount() int {
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	return len(fake.startTaskArgsForCall)
}

func (fake *FakeDB) StartTaskArgsForCall(i int) (lager.Logger, string, string) {
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	return fake.startTaskArgsForCall[i].logger, fake.startTaskArgsForCall[i].taskGuid, fake.startTaskArgsForCall[i].cellId
}

func (fake *FakeDB) StartTaskReturns(result1 *models.Task, result2 *models.Task, result3 bool, result4 error) {
	fake.StartTaskStub = nil
	fake.startTaskReturns = struct {
		result1 *models.Task
		result2 *models.Task
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeDB) StartTaskReturnsOnCall(i int, result1 *models.Task, result2 *models.Task, result3 bool, result4 error) {
	fake.StartTaskStub = nil
	if fake.startTaskReturnsOnCall == nil {
		fake.startTaskReturnsOnCall = make(map[int]struct {
			result1 *models.Task
			result2 *models.Task
			result3 bool
			result4 error
		})
	}
	fake.startTaskReturnsOnCall[i] = struct {
		result1 *models.Task
		result2 *models.Task
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeDB) CancelTask(logger lager.Logger, taskGuid string) (before *models.Task, after *models.Task, cellID string, err error) {
	fake.cancelTaskMutex.Lock()
	ret, specificReturn := fake.cancelTaskReturnsOnCall[len(fake.cancelTaskArgsForCall)]
	fake.cancelTaskArgsForCall = append(fake.cancelTaskArgsForCall, struct {
		logger   lager.Logger
		taskGuid string
	}{logger, taskGuid})
	fake.recordInvocation("CancelTask", []interface{}{logger, taskGuid})
	fake.cancelTaskMutex.Unlock()
	if fake.CancelTaskStub != nil {
		return fake.CancelTaskStub(logger, taskGuid)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fake.cancelTaskReturns.result1, fake.cancelTaskReturns.result2, fake.cancelTaskReturns.result3, fake.cancelTaskReturns.result4
}

func (fake *FakeDB) CancelTaskCallCount() int {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	return len(fake.cancelTaskArgsForCall)
}

func (fake *FakeDB) CancelTaskArgsForCall(i int) (lager.Logger, string) {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	return fake.cancelTaskArgsForCall[i].logger, fake.cancelTaskArgsForCall[i].taskGuid
}

func (fake *FakeDB) CancelTaskReturns(result1 *models.Task, result2 *models.Task, result3 string, result4 error) {
	fake.CancelTaskStub = nil
	fake.cancelTaskReturns = struct {
		result1 *models.Task
		result2 *models.Task
		result3 string
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeDB) CancelTaskReturnsOnCall(i int, result1 *models.Task, result2 *models.Task, result3 string, result4 error) {
	fake.CancelTaskStub = nil
	if fake.cancelTaskReturnsOnCall == nil {
		fake.cancelTaskReturnsOnCall = make(map[int]struct {
			result1 *models.Task
			result2 *models.Task
			result3 string
			result4 error
		})
	}
	fake.cancelTaskReturnsOnCall[i] = struct {
		result1 *models.Task
		result2 *models.Task
		result3 string
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeDB) FailTask(logger lager.Logger, taskGuid string, failureReason string) (before *models.Task, after *models.Task, err error) {
	fake.failTaskMutex.Lock()
	ret, specificReturn := fake.failTaskReturnsOnCall[len(fake.failTaskArgsForCall)]
	fake.failTaskArgsForCall = append(fake.failTaskArgsForCall, struct {
		logger        lager.Logger
		taskGuid      string
		failureReason string
	}{logger, taskGuid, failureReason})
	fake.recordInvocation("FailTask", []interface{}{logger, taskGuid, failureReason})
	fake.failTaskMutex.Unlock()
	if fake.FailTaskStub != nil {
		return fake.FailTaskStub(logger, taskGuid, failureReason)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.failTaskReturns.result1, fake.failTaskReturns.result2, fake.failTaskReturns.result3
}

func (fake *FakeDB) FailTaskCallCount() int {
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	return len(fake.failTaskArgsForCall)
}

func (fake *FakeDB) FailTaskArgsForCall(i int) (lager.Logger, string, string) {
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	return fake.failTaskArgsForCall[i].logger, fake.failTaskArgsForCall[i].taskGuid, fake.failTaskArgsForCall[i].failureReason
}

func (fake *FakeDB) FailTaskReturns(result1 *models.Task, result2 *models.Task, result3 error) {
	fake.FailTaskStub = nil
	fake.failTaskReturns = struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) FailTaskReturnsOnCall(i int, result1 *models.Task, result2 *models.Task, result3 error) {
	fake.FailTaskStub = nil
	if fake.failTaskReturnsOnCall == nil {
		fake.failTaskReturnsOnCall = make(map[int]struct {
			result1 *models.Task
			result2 *models.Task
			result3 error
		})
	}
	fake.failTaskReturnsOnCall[i] = struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) RejectTask(logger lager.Logger, taskGuid string, rejectionReason string) (before *models.Task, after *models.Task, err error) {
	fake.rejectTaskMutex.Lock()
	ret, specificReturn := fake.rejectTaskReturnsOnCall[len(fake.rejectTaskArgsForCall)]
	fake.rejectTaskArgsForCall = append(fake.rejectTaskArgsForCall, struct {
		logger          lager.Logger
		taskGuid        string
		rejectionReason string
	}{logger, taskGuid, rejectionReason})
	fake.recordInvocation("RejectTask", []interface{}{logger, taskGuid, rejectionReason})
	fake.rejectTaskMutex.Unlock()
	if fake.RejectTaskStub != nil {
		return fake.RejectTaskStub(logger, taskGuid, rejectionReason)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.rejectTaskReturns.result1, fake.rejectTaskReturns.result2, fake.rejectTaskReturns.result3
}

func (fake *FakeDB) RejectTaskCallCount() int {
	fake.rejectTaskMutex.RLock()
	defer fake.rejectTaskMutex.RUnlock()
	return len(fake.rejectTaskArgsForCall)
}

func (fake *FakeDB) RejectTaskArgsForCall(i int) (lager.Logger, string, string) {
	fake.rejectTaskMutex.RLock()
	defer fake.rejectTaskMutex.RUnlock()
	return fake.rejectTaskArgsForCall[i].logger, fake.rejectTaskArgsForCall[i].taskGuid, fake.rejectTaskArgsForCall[i].rejectionReason
}

func (fake *FakeDB) RejectTaskReturns(result1 *models.Task, result2 *models.Task, result3 error) {
	fake.RejectTaskStub = nil
	fake.rejectTaskReturns = struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) RejectTaskReturnsOnCall(i int, result1 *models.Task, result2 *models.Task, result3 error) {
	fake.RejectTaskStub = nil
	if fake.rejectTaskReturnsOnCall == nil {
		fake.rejectTaskReturnsOnCall = make(map[int]struct {
			result1 *models.Task
			result2 *models.Task
			result3 error
		})
	}
	fake.rejectTaskReturnsOnCall[i] = struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) CompleteTask(logger lager.Logger, taskGuid string, cellId string, failed bool, failureReason string, result string) (before *models.Task, after *models.Task, err error) {
	fake.completeTaskMutex.Lock()
	ret, specificReturn := fake.completeTaskReturnsOnCall[len(fake.completeTaskArgsForCall)]
	fake.completeTaskArgsForCall = append(fake.completeTaskArgsForCall, struct {
		logger        lager.Logger
		taskGuid      string
		cellId        string
		failed        bool
		failureReason string
		result        string
	}{logger, taskGuid, cellId, failed, failureReason, result})
	fake.recordInvocation("CompleteTask", []interface{}{logger, taskGuid, cellId, failed, failureReason, result})
	fake.completeTaskMutex.Unlock()
	if fake.CompleteTaskStub != nil {
		return fake.CompleteTaskStub(logger, taskGuid, cellId, failed, failureReason, result)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.completeTaskReturns.result1, fake.completeTaskReturns.result2, fake.completeTaskReturns.result3
}

func (fake *FakeDB) CompleteTaskCallCount() int {
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	return len(fake.completeTaskArgsForCall)
}

func (fake *FakeDB) CompleteTaskArgsForCall(i int) (lager.Logger, string, string, bool, string, string) {
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	return fake.completeTaskArgsForCall[i].logger, fake.completeTaskArgsForCall[i].taskGuid, fake.completeTaskArgsForCall[i].cellId, fake.completeTaskArgsForCall[i].failed, fake.completeTaskArgsForCall[i].failureReason, fake.completeTaskArgsForCall[i].result
}

func (fake *FakeDB) CompleteTaskReturns(result1 *models.Task, result2 *models.Task, result3 error) {
	fake.CompleteTaskStub = nil
	fake.completeTaskReturns = struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) CompleteTaskReturnsOnCall(i int, result1 *models.Task, result2 *models.Task, result3 error) {
	fake.CompleteTaskStub = nil
	if fake.completeTaskReturnsOnCall == nil {
		fake.completeTaskReturnsOnCall = make(map[int]struct {
			result1 *models.Task
			result2 *models.Task
			result3 error
		})
	}
	fake.completeTaskReturnsOnCall[i] = struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) ResolvingTask(logger lager.Logger, taskGuid string) (before *models.Task, after *models.Task, err error) {
	fake.resolvingTaskMutex.Lock()
	ret, specificReturn := fake.resolvingTaskReturnsOnCall[len(fake.resolvingTaskArgsForCall)]
	fake.resolvingTaskArgsForCall = append(fake.resolvingTaskArgsForCall, struct {
		logger   lager.Logger
		taskGuid string
	}{logger, taskGuid})
	fake.recordInvocation("ResolvingTask", []interface{}{logger, taskGuid})
	fake.resolvingTaskMutex.Unlock()
	if fake.ResolvingTaskStub != nil {
		return fake.ResolvingTaskStub(logger, taskGuid)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.resolvingTaskReturns.result1, fake.resolvingTaskReturns.result2, fake.resolvingTaskReturns.result3
}

func (fake *FakeDB) ResolvingTaskCallCount() int {
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	return len(fake.resolvingTaskArgsForCall)
}

func (fake *FakeDB) ResolvingTaskArgsForCall(i int) (lager.Logger, string) {
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	return fake.resolvingTaskArgsForCall[i].logger, fake.resolvingTaskArgsForCall[i].taskGuid
}

func (fake *FakeDB) ResolvingTaskReturns(result1 *models.Task, result2 *models.Task, result3 error) {
	fake.ResolvingTaskStub = nil
	fake.resolvingTaskReturns = struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) ResolvingTaskReturnsOnCall(i int, result1 *models.Task, result2 *models.Task, result3 error) {
	fake.ResolvingTaskStub = nil
	if fake.resolvingTaskReturnsOnCall == nil {
		fake.resolvingTaskReturnsOnCall = make(map[int]struct {
			result1 *models.Task
			result2 *models.Task
			result3 error
		})
	}
	fake.resolvingTaskReturnsOnCall[i] = struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) DeleteTask(logger lager.Logger, taskGuid string) (task *models.Task, err error) {
	fake.deleteTaskMutex.Lock()
	ret, specificReturn := fake.deleteTaskReturnsOnCall[len(fake.deleteTaskArgsForCall)]
	fake.deleteTaskArgsForCall = append(fake.deleteTaskArgsForCall, struct {
		logger   lager.Logger
		taskGuid string
	}{logger, taskGuid})
	fake.recordInvocation("DeleteTask", []interface{}{logger, taskGuid})
	fake.deleteTaskMutex.Unlock()
	if fake.DeleteTaskStub != nil {
		return fake.DeleteTaskStub(logger, taskGuid)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.deleteTaskReturns.result1, fake.deleteTaskReturns.result2
}

func (fake *FakeDB) DeleteTaskCallCount() int {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	return len(fake.deleteTaskArgsForCall)
}

func (fake *FakeDB) DeleteTaskArgsForCall(i int) (lager.Logger, string) {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	return fake.deleteTaskArgsForCall[i].logger, fake.deleteTaskArgsForCall[i].taskGuid
}

func (fake *FakeDB) DeleteTaskReturns(result1 *models.Task, result2 error) {
	fake.DeleteTaskStub = nil
	fake.deleteTaskReturns = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DeleteTaskReturnsOnCall(i int, result1 *models.Task, result2 error) {
	fake.DeleteTaskStub = nil
	if fake.deleteTaskReturnsOnCall == nil {
		fake.deleteTaskReturnsOnCall = make(map[int]struct {
			result1 *models.Task
			result2 error
		})
	}
	fake.deleteTaskReturnsOnCall[i] = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) ConvergeTasks(logger lager.Logger, cellSet models.CellSet, kickTaskDuration time.Duration, expirePendingTaskDuration time.Duration, expireCompletedTaskDuration time.Duration) db.TaskConvergenceResult {
	fake.convergeTasksMutex.Lock()
	ret, specificReturn := fake.convergeTasksReturnsOnCall[len(fake.convergeTasksArgsForCall)]
	fake.convergeTasksArgsForCall = append(fake.convergeTasksArgsForCall, struct {
		logger                      lager.Logger
		cellSet                     models.CellSet
		kickTaskDuration            time.Duration
		expirePendingTaskDuration   time.Duration
		expireCompletedTaskDuration time.Duration
	}{logger, cellSet, kickTaskDuration, expirePendingTaskDuration, expireCompletedTaskDuration})
	fake.recordInvocation("ConvergeTasks", []interface{}{logger, cellSet, kickTaskDuration, expirePendingTaskDuration, expireCompletedTaskDuration})
	fake.convergeTasksMutex.Unlock()
	if fake.ConvergeTasksStub != nil {
		return fake.ConvergeTasksStub(logger, cellSet, kickTaskDuration, expirePendingTaskDuration, expireCompletedTaskDuration)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.convergeTasksReturns.result1
}

func (fake *FakeDB) ConvergeTasksCallCount() int {
	fake.convergeTasksMutex.RLock()
	defer fake.convergeTasksMutex.RUnlock()
	return len(fake.convergeTasksArgsForCall)
}

func (fake *FakeDB) ConvergeTasksArgsForCall(i int) (lager.Logger, models.CellSet, time.Duration, time.Duration, time.Duration) {
	fake.convergeTasksMutex.RLock()
	defer fake.convergeTasksMutex.RUnlock()
	return fake.convergeTasksArgsForCall[i].logger, fake.convergeTasksArgsForCall[i].cellSet, fake.convergeTasksArgsForCall[i].kickTaskDuration, fake.convergeTasksArgsForCall[i].expirePendingTaskDuration, fake.convergeTasksArgsForCall[i].expireCompletedTaskDuration
}

func (fake *FakeDB) ConvergeTasksReturns(result1 db.TaskConvergenceResult) {
	fake.ConvergeTasksStub = nil
	fake.convergeTasksReturns = struct {
		result1 db.TaskConvergenceResult
	}{result1}
}

func (fake *FakeDB) ConvergeTasksReturnsOnCall(i int, result1 db.TaskConvergenceResult) {
	fake.ConvergeTasksStub = nil
	if fake.convergeTasksReturnsOnCall == nil {
		fake.convergeTasksReturnsOnCall = make(map[int]struct {
			result1 db.TaskConvergenceResult
		})
	}
	fake.convergeTasksReturnsOnCall[i] = struct {
		result1 db.TaskConvergenceResult
	}{result1}
}

func (fake *FakeDB) Version(logger lager.Logger) (*models.Version, error) {
	fake.versionMutex.Lock()
	ret, specificReturn := fake.versionReturnsOnCall[len(fake.versionArgsForCall)]
	fake.versionArgsForCall = append(fake.versionArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("Version", []interface{}{logger})
	fake.versionMutex.Unlock()
	if fake.VersionStub != nil {
		return fake.VersionStub(logger)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.versionReturns.result1, fake.versionReturns.result2
}

func (fake *FakeDB) VersionCallCount() int {
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	return len(fake.versionArgsForCall)
}

func (fake *FakeDB) VersionArgsForCall(i int) lager.Logger {
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	return fake.versionArgsForCall[i].logger
}

func (fake *FakeDB) VersionReturns(result1 *models.Version, result2 error) {
	fake.VersionStub = nil
	fake.versionReturns = struct {
		result1 *models.Version
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) VersionReturnsOnCall(i int, result1 *models.Version, result2 error) {
	fake.VersionStub = nil
	if fake.versionReturnsOnCall == nil {
		fake.versionReturnsOnCall = make(map[int]struct {
			result1 *models.Version
			result2 error
		})
	}
	fake.versionReturnsOnCall[i] = struct {
		result1 *models.Version
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) SetVersion(logger lager.Logger, version *models.Version) error {
	fake.setVersionMutex.Lock()
	ret, specificReturn := fake.setVersionReturnsOnCall[len(fake.setVersionArgsForCall)]
	fake.setVersionArgsForCall = append(fake.setVersionArgsForCall, struct {
		logger  lager.Logger
		version *models.Version
	}{logger, version})
	fake.recordInvocation("SetVersion", []interface{}{logger, version})
	fake.setVersionMutex.Unlock()
	if fake.SetVersionStub != nil {
		return fake.SetVersionStub(logger, version)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setVersionReturns.result1
}

func (fake *FakeDB) SetVersionCallCount() int {
	fake.setVersionMutex.RLock()
	defer fake.setVersionMutex.RUnlock()
	return len(fake.setVersionArgsForCall)
}

func (fake *FakeDB) SetVersionArgsForCall(i int) (lager.Logger, *models.Version) {
	fake.setVersionMutex.RLock()
	defer fake.setVersionMutex.RUnlock()
	return fake.setVersionArgsForCall[i].logger, fake.setVersionArgsForCall[i].version
}

func (fake *FakeDB) SetVersionReturns(result1 error) {
	fake.SetVersionStub = nil
	fake.setVersionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) SetVersionReturnsOnCall(i int, result1 error) {
	fake.SetVersionStub = nil
	if fake.setVersionReturnsOnCall == nil {
		fake.setVersionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setVersionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) RemoveSuspectActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey) (*models.ActualLRP, error) {
	fake.removeSuspectActualLRPMutex.Lock()
	ret, specificReturn := fake.removeSuspectActualLRPReturnsOnCall[len(fake.removeSuspectActualLRPArgsForCall)]
	fake.removeSuspectActualLRPArgsForCall = append(fake.removeSuspectActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
	}{arg1, arg2})
	fake.recordInvocation("RemoveSuspectActualLRP", []interface{}{arg1, arg2})
	fake.removeSuspectActualLRPMutex.Unlock()
	if fake.RemoveSuspectActualLRPStub != nil {
		return fake.RemoveSuspectActualLRPStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.removeSuspectActualLRPReturns.result1, fake.removeSuspectActualLRPReturns.result2
}

func (fake *FakeDB) RemoveSuspectActualLRPCallCount() int {
	fake.removeSuspectActualLRPMutex.RLock()
	defer fake.removeSuspectActualLRPMutex.RUnlock()
	return len(fake.removeSuspectActualLRPArgsForCall)
}

func (fake *FakeDB) RemoveSuspectActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey) {
	fake.removeSuspectActualLRPMutex.RLock()
	defer fake.removeSuspectActualLRPMutex.RUnlock()
	return fake.removeSuspectActualLRPArgsForCall[i].arg1, fake.removeSuspectActualLRPArgsForCall[i].arg2
}

func (fake *FakeDB) RemoveSuspectActualLRPReturns(result1 *models.ActualLRP, result2 error) {
	fake.RemoveSuspectActualLRPStub = nil
	fake.removeSuspectActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) RemoveSuspectActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 error) {
	fake.RemoveSuspectActualLRPStub = nil
	if fake.removeSuspectActualLRPReturnsOnCall == nil {
		fake.removeSuspectActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 error
		})
	}
	fake.removeSuspectActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.freshDomainsMutex.RLock()
	defer fake.freshDomainsMutex.RUnlock()
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	fake.encryptionKeyLabelMutex.RLock()
	defer fake.encryptionKeyLabelMutex.RUnlock()
	fake.setEncryptionKeyLabelMutex.RLock()
	defer fake.setEncryptionKeyLabelMutex.RUnlock()
	fake.performEncryptionMutex.RLock()
	defer fake.performEncryptionMutex.RUnlock()
	fake.removeEvacuatingActualLRPMutex.RLock()
	defer fake.removeEvacuatingActualLRPMutex.RUnlock()
	fake.evacuateActualLRPMutex.RLock()
	defer fake.evacuateActualLRPMutex.RUnlock()
	fake.actualLRPsMutex.RLock()
	defer fake.actualLRPsMutex.RUnlock()
	fake.createUnclaimedActualLRPMutex.RLock()
	defer fake.createUnclaimedActualLRPMutex.RUnlock()
	fake.unclaimActualLRPMutex.RLock()
	defer fake.unclaimActualLRPMutex.RUnlock()
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	fake.changeActualLRPPresenceMutex.RLock()
	defer fake.changeActualLRPPresenceMutex.RUnlock()
	fake.countActualLRPsByStateMutex.RLock()
	defer fake.countActualLRPsByStateMutex.RUnlock()
	fake.countDesiredInstancesMutex.RLock()
	defer fake.countDesiredInstancesMutex.RUnlock()
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	fake.convergeLRPsMutex.RLock()
	defer fake.convergeLRPsMutex.RUnlock()
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	fake.rejectTaskMutex.RLock()
	defer fake.rejectTaskMutex.RUnlock()
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	fake.convergeTasksMutex.RLock()
	defer fake.convergeTasksMutex.RUnlock()
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	fake.setVersionMutex.RLock()
	defer fake.setVersionMutex.RUnlock()
	fake.removeSuspectActualLRPMutex.RLock()
	defer fake.removeSuspectActualLRPMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDB) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.DB = new(FakeDB)
