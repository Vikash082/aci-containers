// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"sync"

	"code.cloudfoundry.org/bbs/db"
	"code.cloudfoundry.org/bbs/models"
	"code.cloudfoundry.org/lager"
)

type FakeActualLRPDB struct {
	ActualLRPsStub        func(logger lager.Logger, filter models.ActualLRPFilter) ([]*models.ActualLRP, error)
	actualLRPsMutex       sync.RWMutex
	actualLRPsArgsForCall []struct {
		logger lager.Logger
		filter models.ActualLRPFilter
	}
	actualLRPsReturns struct {
		result1 []*models.ActualLRP
		result2 error
	}
	actualLRPsReturnsOnCall map[int]struct {
		result1 []*models.ActualLRP
		result2 error
	}
	CreateUnclaimedActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey) (after *models.ActualLRP, err error)
	createUnclaimedActualLRPMutex       sync.RWMutex
	createUnclaimedActualLRPArgsForCall []struct {
		logger lager.Logger
		key    *models.ActualLRPKey
	}
	createUnclaimedActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 error
	}
	createUnclaimedActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 error
	}
	UnclaimActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey) (before *models.ActualLRP, after *models.ActualLRP, err error)
	unclaimActualLRPMutex       sync.RWMutex
	unclaimActualLRPArgsForCall []struct {
		logger lager.Logger
		key    *models.ActualLRPKey
	}
	unclaimActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	unclaimActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	ClaimActualLRPStub        func(logger lager.Logger, processGuid string, index int32, instanceKey *models.ActualLRPInstanceKey) (before *models.ActualLRP, after *models.ActualLRP, err error)
	claimActualLRPMutex       sync.RWMutex
	claimActualLRPArgsForCall []struct {
		logger      lager.Logger
		processGuid string
		index       int32
		instanceKey *models.ActualLRPInstanceKey
	}
	claimActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	claimActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	StartActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, netInfo *models.ActualLRPNetInfo) (before *models.ActualLRP, after *models.ActualLRP, err error)
	startActualLRPMutex       sync.RWMutex
	startActualLRPArgsForCall []struct {
		logger      lager.Logger
		key         *models.ActualLRPKey
		instanceKey *models.ActualLRPInstanceKey
		netInfo     *models.ActualLRPNetInfo
	}
	startActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	startActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	CrashActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, crashReason string) (before *models.ActualLRP, after *models.ActualLRP, shouldRestart bool, err error)
	crashActualLRPMutex       sync.RWMutex
	crashActualLRPArgsForCall []struct {
		logger      lager.Logger
		key         *models.ActualLRPKey
		instanceKey *models.ActualLRPInstanceKey
		crashReason string
	}
	crashActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 bool
		result4 error
	}
	crashActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 bool
		result4 error
	}
	FailActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey, placementError string) (before *models.ActualLRP, after *models.ActualLRP, err error)
	failActualLRPMutex       sync.RWMutex
	failActualLRPArgsForCall []struct {
		logger         lager.Logger
		key            *models.ActualLRPKey
		placementError string
	}
	failActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	failActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	RemoveActualLRPStub        func(logger lager.Logger, processGuid string, index int32, instanceKey *models.ActualLRPInstanceKey) error
	removeActualLRPMutex       sync.RWMutex
	removeActualLRPArgsForCall []struct {
		logger      lager.Logger
		processGuid string
		index       int32
		instanceKey *models.ActualLRPInstanceKey
	}
	removeActualLRPReturns struct {
		result1 error
	}
	removeActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	ChangeActualLRPPresenceStub        func(logger lager.Logger, key *models.ActualLRPKey, from, to models.ActualLRP_Presence) (before *models.ActualLRP, after *models.ActualLRP, err error)
	changeActualLRPPresenceMutex       sync.RWMutex
	changeActualLRPPresenceArgsForCall []struct {
		logger lager.Logger
		key    *models.ActualLRPKey
		from   models.ActualLRP_Presence
		to     models.ActualLRP_Presence
	}
	changeActualLRPPresenceReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	changeActualLRPPresenceReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	CountActualLRPsByStateStub        func(logger lager.Logger) (int, int, int, int, int)
	countActualLRPsByStateMutex       sync.RWMutex
	countActualLRPsByStateArgsForCall []struct {
		logger lager.Logger
	}
	countActualLRPsByStateReturns struct {
		result1 int
		result2 int
		result3 int
		result4 int
		result5 int
	}
	countActualLRPsByStateReturnsOnCall map[int]struct {
		result1 int
		result2 int
		result3 int
		result4 int
		result5 int
	}
	CountDesiredInstancesStub        func(logger lager.Logger) int
	countDesiredInstancesMutex       sync.RWMutex
	countDesiredInstancesArgsForCall []struct {
		logger lager.Logger
	}
	countDesiredInstancesReturns struct {
		result1 int
	}
	countDesiredInstancesReturnsOnCall map[int]struct {
		result1 int
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeActualLRPDB) ActualLRPs(logger lager.Logger, filter models.ActualLRPFilter) ([]*models.ActualLRP, error) {
	fake.actualLRPsMutex.Lock()
	ret, specificReturn := fake.actualLRPsReturnsOnCall[len(fake.actualLRPsArgsForCall)]
	fake.actualLRPsArgsForCall = append(fake.actualLRPsArgsForCall, struct {
		logger lager.Logger
		filter models.ActualLRPFilter
	}{logger, filter})
	fake.recordInvocation("ActualLRPs", []interface{}{logger, filter})
	fake.actualLRPsMutex.Unlock()
	if fake.ActualLRPsStub != nil {
		return fake.ActualLRPsStub(logger, filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.actualLRPsReturns.result1, fake.actualLRPsReturns.result2
}

func (fake *FakeActualLRPDB) ActualLRPsCallCount() int {
	fake.actualLRPsMutex.RLock()
	defer fake.actualLRPsMutex.RUnlock()
	return len(fake.actualLRPsArgsForCall)
}

func (fake *FakeActualLRPDB) ActualLRPsArgsForCall(i int) (lager.Logger, models.ActualLRPFilter) {
	fake.actualLRPsMutex.RLock()
	defer fake.actualLRPsMutex.RUnlock()
	return fake.actualLRPsArgsForCall[i].logger, fake.actualLRPsArgsForCall[i].filter
}

func (fake *FakeActualLRPDB) ActualLRPsReturns(result1 []*models.ActualLRP, result2 error) {
	fake.ActualLRPsStub = nil
	fake.actualLRPsReturns = struct {
		result1 []*models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeActualLRPDB) ActualLRPsReturnsOnCall(i int, result1 []*models.ActualLRP, result2 error) {
	fake.ActualLRPsStub = nil
	if fake.actualLRPsReturnsOnCall == nil {
		fake.actualLRPsReturnsOnCall = make(map[int]struct {
			result1 []*models.ActualLRP
			result2 error
		})
	}
	fake.actualLRPsReturnsOnCall[i] = struct {
		result1 []*models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeActualLRPDB) CreateUnclaimedActualLRP(logger lager.Logger, key *models.ActualLRPKey) (after *models.ActualLRP, err error) {
	fake.createUnclaimedActualLRPMutex.Lock()
	ret, specificReturn := fake.createUnclaimedActualLRPReturnsOnCall[len(fake.createUnclaimedActualLRPArgsForCall)]
	fake.createUnclaimedActualLRPArgsForCall = append(fake.createUnclaimedActualLRPArgsForCall, struct {
		logger lager.Logger
		key    *models.ActualLRPKey
	}{logger, key})
	fake.recordInvocation("CreateUnclaimedActualLRP", []interface{}{logger, key})
	fake.createUnclaimedActualLRPMutex.Unlock()
	if fake.CreateUnclaimedActualLRPStub != nil {
		return fake.CreateUnclaimedActualLRPStub(logger, key)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createUnclaimedActualLRPReturns.result1, fake.createUnclaimedActualLRPReturns.result2
}

func (fake *FakeActualLRPDB) CreateUnclaimedActualLRPCallCount() int {
	fake.createUnclaimedActualLRPMutex.RLock()
	defer fake.createUnclaimedActualLRPMutex.RUnlock()
	return len(fake.createUnclaimedActualLRPArgsForCall)
}

func (fake *FakeActualLRPDB) CreateUnclaimedActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey) {
	fake.createUnclaimedActualLRPMutex.RLock()
	defer fake.createUnclaimedActualLRPMutex.RUnlock()
	return fake.createUnclaimedActualLRPArgsForCall[i].logger, fake.createUnclaimedActualLRPArgsForCall[i].key
}

func (fake *FakeActualLRPDB) CreateUnclaimedActualLRPReturns(result1 *models.ActualLRP, result2 error) {
	fake.CreateUnclaimedActualLRPStub = nil
	fake.createUnclaimedActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeActualLRPDB) CreateUnclaimedActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 error) {
	fake.CreateUnclaimedActualLRPStub = nil
	if fake.createUnclaimedActualLRPReturnsOnCall == nil {
		fake.createUnclaimedActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 error
		})
	}
	fake.createUnclaimedActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeActualLRPDB) UnclaimActualLRP(logger lager.Logger, key *models.ActualLRPKey) (before *models.ActualLRP, after *models.ActualLRP, err error) {
	fake.unclaimActualLRPMutex.Lock()
	ret, specificReturn := fake.unclaimActualLRPReturnsOnCall[len(fake.unclaimActualLRPArgsForCall)]
	fake.unclaimActualLRPArgsForCall = append(fake.unclaimActualLRPArgsForCall, struct {
		logger lager.Logger
		key    *models.ActualLRPKey
	}{logger, key})
	fake.recordInvocation("UnclaimActualLRP", []interface{}{logger, key})
	fake.unclaimActualLRPMutex.Unlock()
	if fake.UnclaimActualLRPStub != nil {
		return fake.UnclaimActualLRPStub(logger, key)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.unclaimActualLRPReturns.result1, fake.unclaimActualLRPReturns.result2, fake.unclaimActualLRPReturns.result3
}

func (fake *FakeActualLRPDB) UnclaimActualLRPCallCount() int {
	fake.unclaimActualLRPMutex.RLock()
	defer fake.unclaimActualLRPMutex.RUnlock()
	return len(fake.unclaimActualLRPArgsForCall)
}

func (fake *FakeActualLRPDB) UnclaimActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey) {
	fake.unclaimActualLRPMutex.RLock()
	defer fake.unclaimActualLRPMutex.RUnlock()
	return fake.unclaimActualLRPArgsForCall[i].logger, fake.unclaimActualLRPArgsForCall[i].key
}

func (fake *FakeActualLRPDB) UnclaimActualLRPReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.UnclaimActualLRPStub = nil
	fake.unclaimActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) UnclaimActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.UnclaimActualLRPStub = nil
	if fake.unclaimActualLRPReturnsOnCall == nil {
		fake.unclaimActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 error
		})
	}
	fake.unclaimActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) ClaimActualLRP(logger lager.Logger, processGuid string, index int32, instanceKey *models.ActualLRPInstanceKey) (before *models.ActualLRP, after *models.ActualLRP, err error) {
	fake.claimActualLRPMutex.Lock()
	ret, specificReturn := fake.claimActualLRPReturnsOnCall[len(fake.claimActualLRPArgsForCall)]
	fake.claimActualLRPArgsForCall = append(fake.claimActualLRPArgsForCall, struct {
		logger      lager.Logger
		processGuid string
		index       int32
		instanceKey *models.ActualLRPInstanceKey
	}{logger, processGuid, index, instanceKey})
	fake.recordInvocation("ClaimActualLRP", []interface{}{logger, processGuid, index, instanceKey})
	fake.claimActualLRPMutex.Unlock()
	if fake.ClaimActualLRPStub != nil {
		return fake.ClaimActualLRPStub(logger, processGuid, index, instanceKey)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.claimActualLRPReturns.result1, fake.claimActualLRPReturns.result2, fake.claimActualLRPReturns.result3
}

func (fake *FakeActualLRPDB) ClaimActualLRPCallCount() int {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	return len(fake.claimActualLRPArgsForCall)
}

func (fake *FakeActualLRPDB) ClaimActualLRPArgsForCall(i int) (lager.Logger, string, int32, *models.ActualLRPInstanceKey) {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	return fake.claimActualLRPArgsForCall[i].logger, fake.claimActualLRPArgsForCall[i].processGuid, fake.claimActualLRPArgsForCall[i].index, fake.claimActualLRPArgsForCall[i].instanceKey
}

func (fake *FakeActualLRPDB) ClaimActualLRPReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.ClaimActualLRPStub = nil
	fake.claimActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) ClaimActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.ClaimActualLRPStub = nil
	if fake.claimActualLRPReturnsOnCall == nil {
		fake.claimActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 error
		})
	}
	fake.claimActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) StartActualLRP(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, netInfo *models.ActualLRPNetInfo) (before *models.ActualLRP, after *models.ActualLRP, err error) {
	fake.startActualLRPMutex.Lock()
	ret, specificReturn := fake.startActualLRPReturnsOnCall[len(fake.startActualLRPArgsForCall)]
	fake.startActualLRPArgsForCall = append(fake.startActualLRPArgsForCall, struct {
		logger      lager.Logger
		key         *models.ActualLRPKey
		instanceKey *models.ActualLRPInstanceKey
		netInfo     *models.ActualLRPNetInfo
	}{logger, key, instanceKey, netInfo})
	fake.recordInvocation("StartActualLRP", []interface{}{logger, key, instanceKey, netInfo})
	fake.startActualLRPMutex.Unlock()
	if fake.StartActualLRPStub != nil {
		return fake.StartActualLRPStub(logger, key, instanceKey, netInfo)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.startActualLRPReturns.result1, fake.startActualLRPReturns.result2, fake.startActualLRPReturns.result3
}

func (fake *FakeActualLRPDB) StartActualLRPCallCount() int {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	return len(fake.startActualLRPArgsForCall)
}

func (fake *FakeActualLRPDB) StartActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	return fake.startActualLRPArgsForCall[i].logger, fake.startActualLRPArgsForCall[i].key, fake.startActualLRPArgsForCall[i].instanceKey, fake.startActualLRPArgsForCall[i].netInfo
}

func (fake *FakeActualLRPDB) StartActualLRPReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.StartActualLRPStub = nil
	fake.startActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) StartActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.StartActualLRPStub = nil
	if fake.startActualLRPReturnsOnCall == nil {
		fake.startActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 error
		})
	}
	fake.startActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) CrashActualLRP(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, crashReason string) (before *models.ActualLRP, after *models.ActualLRP, shouldRestart bool, err error) {
	fake.crashActualLRPMutex.Lock()
	ret, specificReturn := fake.crashActualLRPReturnsOnCall[len(fake.crashActualLRPArgsForCall)]
	fake.crashActualLRPArgsForCall = append(fake.crashActualLRPArgsForCall, struct {
		logger      lager.Logger
		key         *models.ActualLRPKey
		instanceKey *models.ActualLRPInstanceKey
		crashReason string
	}{logger, key, instanceKey, crashReason})
	fake.recordInvocation("CrashActualLRP", []interface{}{logger, key, instanceKey, crashReason})
	fake.crashActualLRPMutex.Unlock()
	if fake.CrashActualLRPStub != nil {
		return fake.CrashActualLRPStub(logger, key, instanceKey, crashReason)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fake.crashActualLRPReturns.result1, fake.crashActualLRPReturns.result2, fake.crashActualLRPReturns.result3, fake.crashActualLRPReturns.result4
}

func (fake *FakeActualLRPDB) CrashActualLRPCallCount() int {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	return len(fake.crashActualLRPArgsForCall)
}

func (fake *FakeActualLRPDB) CrashActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	return fake.crashActualLRPArgsForCall[i].logger, fake.crashActualLRPArgsForCall[i].key, fake.crashActualLRPArgsForCall[i].instanceKey, fake.crashActualLRPArgsForCall[i].crashReason
}

func (fake *FakeActualLRPDB) CrashActualLRPReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 bool, result4 error) {
	fake.CrashActualLRPStub = nil
	fake.crashActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeActualLRPDB) CrashActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 bool, result4 error) {
	fake.CrashActualLRPStub = nil
	if fake.crashActualLRPReturnsOnCall == nil {
		fake.crashActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 bool
			result4 error
		})
	}
	fake.crashActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeActualLRPDB) FailActualLRP(logger lager.Logger, key *models.ActualLRPKey, placementError string) (before *models.ActualLRP, after *models.ActualLRP, err error) {
	fake.failActualLRPMutex.Lock()
	ret, specificReturn := fake.failActualLRPReturnsOnCall[len(fake.failActualLRPArgsForCall)]
	fake.failActualLRPArgsForCall = append(fake.failActualLRPArgsForCall, struct {
		logger         lager.Logger
		key            *models.ActualLRPKey
		placementError string
	}{logger, key, placementError})
	fake.recordInvocation("FailActualLRP", []interface{}{logger, key, placementError})
	fake.failActualLRPMutex.Unlock()
	if fake.FailActualLRPStub != nil {
		return fake.FailActualLRPStub(logger, key, placementError)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.failActualLRPReturns.result1, fake.failActualLRPReturns.result2, fake.failActualLRPReturns.result3
}

func (fake *FakeActualLRPDB) FailActualLRPCallCount() int {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	return len(fake.failActualLRPArgsForCall)
}

func (fake *FakeActualLRPDB) FailActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, string) {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	return fake.failActualLRPArgsForCall[i].logger, fake.failActualLRPArgsForCall[i].key, fake.failActualLRPArgsForCall[i].placementError
}

func (fake *FakeActualLRPDB) FailActualLRPReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.FailActualLRPStub = nil
	fake.failActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) FailActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.FailActualLRPStub = nil
	if fake.failActualLRPReturnsOnCall == nil {
		fake.failActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 error
		})
	}
	fake.failActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) RemoveActualLRP(logger lager.Logger, processGuid string, index int32, instanceKey *models.ActualLRPInstanceKey) error {
	fake.removeActualLRPMutex.Lock()
	ret, specificReturn := fake.removeActualLRPReturnsOnCall[len(fake.removeActualLRPArgsForCall)]
	fake.removeActualLRPArgsForCall = append(fake.removeActualLRPArgsForCall, struct {
		logger      lager.Logger
		processGuid string
		index       int32
		instanceKey *models.ActualLRPInstanceKey
	}{logger, processGuid, index, instanceKey})
	fake.recordInvocation("RemoveActualLRP", []interface{}{logger, processGuid, index, instanceKey})
	fake.removeActualLRPMutex.Unlock()
	if fake.RemoveActualLRPStub != nil {
		return fake.RemoveActualLRPStub(logger, processGuid, index, instanceKey)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeActualLRPReturns.result1
}

func (fake *FakeActualLRPDB) RemoveActualLRPCallCount() int {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	return len(fake.removeActualLRPArgsForCall)
}

func (fake *FakeActualLRPDB) RemoveActualLRPArgsForCall(i int) (lager.Logger, string, int32, *models.ActualLRPInstanceKey) {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	return fake.removeActualLRPArgsForCall[i].logger, fake.removeActualLRPArgsForCall[i].processGuid, fake.removeActualLRPArgsForCall[i].index, fake.removeActualLRPArgsForCall[i].instanceKey
}

func (fake *FakeActualLRPDB) RemoveActualLRPReturns(result1 error) {
	fake.RemoveActualLRPStub = nil
	fake.removeActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPDB) RemoveActualLRPReturnsOnCall(i int, result1 error) {
	fake.RemoveActualLRPStub = nil
	if fake.removeActualLRPReturnsOnCall == nil {
		fake.removeActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPDB) ChangeActualLRPPresence(logger lager.Logger, key *models.ActualLRPKey, from models.ActualLRP_Presence, to models.ActualLRP_Presence) (before *models.ActualLRP, after *models.ActualLRP, err error) {
	fake.changeActualLRPPresenceMutex.Lock()
	ret, specificReturn := fake.changeActualLRPPresenceReturnsOnCall[len(fake.changeActualLRPPresenceArgsForCall)]
	fake.changeActualLRPPresenceArgsForCall = append(fake.changeActualLRPPresenceArgsForCall, struct {
		logger lager.Logger
		key    *models.ActualLRPKey
		from   models.ActualLRP_Presence
		to     models.ActualLRP_Presence
	}{logger, key, from, to})
	fake.recordInvocation("ChangeActualLRPPresence", []interface{}{logger, key, from, to})
	fake.changeActualLRPPresenceMutex.Unlock()
	if fake.ChangeActualLRPPresenceStub != nil {
		return fake.ChangeActualLRPPresenceStub(logger, key, from, to)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.changeActualLRPPresenceReturns.result1, fake.changeActualLRPPresenceReturns.result2, fake.changeActualLRPPresenceReturns.result3
}

func (fake *FakeActualLRPDB) ChangeActualLRPPresenceCallCount() int {
	fake.changeActualLRPPresenceMutex.RLock()
	defer fake.changeActualLRPPresenceMutex.RUnlock()
	return len(fake.changeActualLRPPresenceArgsForCall)
}

func (fake *FakeActualLRPDB) ChangeActualLRPPresenceArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, models.ActualLRP_Presence, models.ActualLRP_Presence) {
	fake.changeActualLRPPresenceMutex.RLock()
	defer fake.changeActualLRPPresenceMutex.RUnlock()
	return fake.changeActualLRPPresenceArgsForCall[i].logger, fake.changeActualLRPPresenceArgsForCall[i].key, fake.changeActualLRPPresenceArgsForCall[i].from, fake.changeActualLRPPresenceArgsForCall[i].to
}

func (fake *FakeActualLRPDB) ChangeActualLRPPresenceReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.ChangeActualLRPPresenceStub = nil
	fake.changeActualLRPPresenceReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) ChangeActualLRPPresenceReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.ChangeActualLRPPresenceStub = nil
	if fake.changeActualLRPPresenceReturnsOnCall == nil {
		fake.changeActualLRPPresenceReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 error
		})
	}
	fake.changeActualLRPPresenceReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) CountActualLRPsByState(logger lager.Logger) (int, int, int, int, int) {
	fake.countActualLRPsByStateMutex.Lock()
	ret, specificReturn := fake.countActualLRPsByStateReturnsOnCall[len(fake.countActualLRPsByStateArgsForCall)]
	fake.countActualLRPsByStateArgsForCall = append(fake.countActualLRPsByStateArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("CountActualLRPsByState", []interface{}{logger})
	fake.countActualLRPsByStateMutex.Unlock()
	if fake.CountActualLRPsByStateStub != nil {
		return fake.CountActualLRPsByStateStub(logger)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4, ret.result5
	}
	return fake.countActualLRPsByStateReturns.result1, fake.countActualLRPsByStateReturns.result2, fake.countActualLRPsByStateReturns.result3, fake.countActualLRPsByStateReturns.result4, fake.countActualLRPsByStateReturns.result5
}

func (fake *FakeActualLRPDB) CountActualLRPsByStateCallCount() int {
	fake.countActualLRPsByStateMutex.RLock()
	defer fake.countActualLRPsByStateMutex.RUnlock()
	return len(fake.countActualLRPsByStateArgsForCall)
}

func (fake *FakeActualLRPDB) CountActualLRPsByStateArgsForCall(i int) lager.Logger {
	fake.countActualLRPsByStateMutex.RLock()
	defer fake.countActualLRPsByStateMutex.RUnlock()
	return fake.countActualLRPsByStateArgsForCall[i].logger
}

func (fake *FakeActualLRPDB) CountActualLRPsByStateReturns(result1 int, result2 int, result3 int, result4 int, result5 int) {
	fake.CountActualLRPsByStateStub = nil
	fake.countActualLRPsByStateReturns = struct {
		result1 int
		result2 int
		result3 int
		result4 int
		result5 int
	}{result1, result2, result3, result4, result5}
}

func (fake *FakeActualLRPDB) CountActualLRPsByStateReturnsOnCall(i int, result1 int, result2 int, result3 int, result4 int, result5 int) {
	fake.CountActualLRPsByStateStub = nil
	if fake.countActualLRPsByStateReturnsOnCall == nil {
		fake.countActualLRPsByStateReturnsOnCall = make(map[int]struct {
			result1 int
			result2 int
			result3 int
			result4 int
			result5 int
		})
	}
	fake.countActualLRPsByStateReturnsOnCall[i] = struct {
		result1 int
		result2 int
		result3 int
		result4 int
		result5 int
	}{result1, result2, result3, result4, result5}
}

func (fake *FakeActualLRPDB) CountDesiredInstances(logger lager.Logger) int {
	fake.countDesiredInstancesMutex.Lock()
	ret, specificReturn := fake.countDesiredInstancesReturnsOnCall[len(fake.countDesiredInstancesArgsForCall)]
	fake.countDesiredInstancesArgsForCall = append(fake.countDesiredInstancesArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("CountDesiredInstances", []interface{}{logger})
	fake.countDesiredInstancesMutex.Unlock()
	if fake.CountDesiredInstancesStub != nil {
		return fake.CountDesiredInstancesStub(logger)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.countDesiredInstancesReturns.result1
}

func (fake *FakeActualLRPDB) CountDesiredInstancesCallCount() int {
	fake.countDesiredInstancesMutex.RLock()
	defer fake.countDesiredInstancesMutex.RUnlock()
	return len(fake.countDesiredInstancesArgsForCall)
}

func (fake *FakeActualLRPDB) CountDesiredInstancesArgsForCall(i int) lager.Logger {
	fake.countDesiredInstancesMutex.RLock()
	defer fake.countDesiredInstancesMutex.RUnlock()
	return fake.countDesiredInstancesArgsForCall[i].logger
}

func (fake *FakeActualLRPDB) CountDesiredInstancesReturns(result1 int) {
	fake.CountDesiredInstancesStub = nil
	fake.countDesiredInstancesReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeActualLRPDB) CountDesiredInstancesReturnsOnCall(i int, result1 int) {
	fake.CountDesiredInstancesStub = nil
	if fake.countDesiredInstancesReturnsOnCall == nil {
		fake.countDesiredInstancesReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.countDesiredInstancesReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeActualLRPDB) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.actualLRPsMutex.RLock()
	defer fake.actualLRPsMutex.RUnlock()
	fake.createUnclaimedActualLRPMutex.RLock()
	defer fake.createUnclaimedActualLRPMutex.RUnlock()
	fake.unclaimActualLRPMutex.RLock()
	defer fake.unclaimActualLRPMutex.RUnlock()
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	fake.changeActualLRPPresenceMutex.RLock()
	defer fake.changeActualLRPPresenceMutex.RUnlock()
	fake.countActualLRPsByStateMutex.RLock()
	defer fake.countActualLRPsByStateMutex.RUnlock()
	fake.countDesiredInstancesMutex.RLock()
	defer fake.countDesiredInstancesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeActualLRPDB) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.ActualLRPDB = new(FakeActualLRPDB)
